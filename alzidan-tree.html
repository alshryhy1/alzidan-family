<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8" />
    <title>شجرة عائلة الزيدان</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        html, body {
            max-width: 100%;
            overflow-x: hidden;
        }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
        }
        .page {
            max-width: 960px;
            margin: 0 auto;
            padding: 24px 16px 40px;
        }
        h1 {
            font-size: 26px;
            margin: 0 0 4px 0;
            color: #1f2933;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 24px;
            font-size: 14px;
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            padding: 20px 16px;
            box-shadow: 0 4px 10px rgba(15, 23, 42, 0.06);
            margin-bottom: 16px;
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #111827;
        }
        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 4px;
        }
        select, input[type="text"], input[type="tel"], input[type="number"], input[type="password"], input[type="date"], input[type="time"], textarea {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            font-size: 14px;
            box-sizing: border-box;
        }
        input[type="date"], input[type="time"] {
            direction: ltr;
            text-align: left;
        }
        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.2);
        }
        .btn {
            border: none;
            padding: 9px 18px;
            border-radius: 999px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            max-width: 100%;
            white-space: normal;
        }
        .btn-primary {
            background-color: #2563eb;
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #1d4ed8;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #111827;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        .field {
            margin-bottom: 10px;
        }
        .hint {
            font-size: 12px;
            color: #6b7280;
            margin-top: 2px;
        }
        .alert {
            margin-top: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 13px;
        }
        .alert-success {
            background-color: #ecfdf5;
            color: #166534;
            border: 1px solid #bbf7d0;
        }
        .alert-error {
            background-color: #fef2f2;
            color: #b91c1c;
            border: 1px solid #fecaca;
        }
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 11px;
            background-color: #eff6ff;
            color: #1d4ed8;
        }
        .section-title {
            font-size: 15px;
            font-weight: 600;
            margin: 4px 0 10px;
            color: #111827;
        }
        .parent-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            margin-bottom: 6px;
            gap: 8px;
            font-size: 14px;
        }
        .parent-name {
            font-weight: 500;
        }
        .children-list {
            margin-top: 10px;
            border-top: 1px dashed #e5e7eb;
            padding-top: 8px;
        }
        .child-row {
            font-size: 13px;
            padding: 4px 0;
            border-bottom: 1px solid #f3f4f6;
        }
        .tree-node {
            margin-bottom: 6px;
        }
        .tree-node,
        .parent-row {
            min-width: 150px;
            flex: 0 0 auto;
        }
        .tree-node > summary {
            list-style: none;
            cursor: pointer;
        }
        .tree-node > summary::-webkit-details-marker {
            display: none;
        }
        .tree-node-children {
            margin-top: 6px;
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 8px;
            padding-bottom: 4px;
            scroll-snap-type: x proximity;
        }
        .tree-node-children > * {
            scroll-snap-align: start;
        }
        .child-location {
            color: #6b7280;
        }
        .event-row {
            font-size: 13px;
            padding: 6px 0;
            border-bottom: 1px solid #f3f4f6;
        }
        .event-meta {
            font-size: 12px;
            color: #6b7280;
            margin-top: 2px;
            overflow-wrap: anywhere;
        }
        .event-row {
            overflow-wrap: anywhere;
        }
        .toggle-card {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0;
            margin-top: 12px;
            background: #ffffff;
        }
        .toggle-card > summary {
            list-style: none;
            cursor: pointer;
            padding: 12px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            user-select: none;
        }
        .toggle-card > summary::-webkit-details-marker {
            display: none;
        }
        .toggle-title {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }
        .toggle-title-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }
        .toggle-title-main {
            font-weight: 800;
            font-size: 14px;
        }
        .toggle-title-sub {
            font-size: 12px;
            color: #6b7280;
            overflow-wrap: anywhere;
        }
        .toggle-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            flex: 0 0 auto;
        }
        .toggle-chevron {
            color: #6b7280;
            font-size: 18px;
            transition: transform 160ms ease;
            flex: 0 0 auto;
        }
        .toggle-card[open] > summary .toggle-chevron {
            transform: rotate(90deg);
        }
        .toggle-body {
            padding: 0 12px 12px;
        }
        .row-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        @media (max-width: 600px) {
            .card {
                padding: 16px 12px;
            }
            .parent-row {
                flex-direction: column;
                align-items: flex-start;
            }
            .card-header {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        @media (max-width: 420px) {
            .page {
                padding: 18px 12px 32px;
            }
            h1 {
                font-size: 24px;
            }
            .subtitle {
                margin-bottom: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <h1>شجرة عائلة الزيدان</h1>
        <div class="subtitle">نموذج أولي مستقل لجمع بيانات الأبناء وتنظيم فروع العائلة</div>

        <div id="tree-card" class="card">
            <div class="card-header">
                <div class="card-title" id="tree-title">شجرة العائلة</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <a href="index.html" class="btn btn-secondary btn-small">الصفحة الرئيسية</a>
                    <button id="open-delegate" class="btn btn-primary btn-small" type="button">دخول المناديب</button>
                </div>
            </div>
            <div class="grid">
                <div class="field">
                    <label for="tree-branch">فرع العائلة</label>
                    <select id="tree-branch">
                        <option value="">اختر الفرع</option>
                        <option value="زيدان">زيدان بن مطلق بن زيدان</option>
                        <option value="مزيد">مزيد بن مطلق بن زيدان</option>
                        <option value="زايد">زايد بن مطلق بن زيدان</option>
                        <option value="لاحم">لاحم بن مطلق بن زيدان</option>
                        <option value="ملحم">ملحم بن مطلق بن زيدان</option>
                    </select>
                    <div class="hint">عرض مختصر للفرع (قائمة الآباء الحالية).</div>
                </div>
            </div>
            <div class="field" style="margin-top: 8px;">
                <div class="section-title">الآباء في هذا الفرع</div>
                <div id="tree-list" class="children-list"></div>
            </div>
        </div>

        <div id="login-card" class="card">
            <div class="card-header">
                <div class="card-title">دخول مناديب الفروع</div>
                <a href="index.html" class="btn btn-secondary btn-small">الصفحة الرئيسية</a>
            </div>
            <div class="grid">
                <div class="field">
                    <label for="branch">فرع العائلة</label>
                    <select id="branch">
                        <option value="">اختر الفرع</option>
                        <option value="زيدان">زيدان بن مطلق بن زيدان</option>
                        <option value="مزيد">مزيد بن مطلق بن زيدان</option>
                        <option value="زايد">زايد بن مطلق بن زيدان</option>
                        <option value="لاحم">لاحم بن مطلق بن زيدان</option>
                        <option value="ملحم">ملحم بن مطلق بن زيدان</option>
                    </select>
                </div>
                <div class="field">
                    <label for="phone">رقم الجوال</label>
                    <input id="phone" type="tel" placeholder="05xxxxxxxx" />
                </div>
                <div class="field">
                    <label for="email">البريد الإلكتروني</label>
                    <input id="email" type="email" placeholder="name@example.com" />
                </div>
                <div class="field">
                    <label for="code">الرقم السري</label>
                    <input id="code" type="password" placeholder="الرقم السري الذي اخترته" />
                    <div class="hint">للدخول يلزم اعتماد الطلب أولاً. إذا لم يتم اعتمادك بعد، سجّل طلب دخول وسيتم مراجعته.</div>
                </div>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="login-btn" class="btn btn-primary" type="button">دخول المندوب</button>
                <button id="forgot-btn" class="btn btn-secondary btn-small" type="button">نسيت الرقم السري</button>
            </div>
            <div id="login-alert" class="alert" style="display: none;"></div>
        </div>

        <div id="dashboard-card" class="card" style="display: none;">
                <div class="card-header">
                    <div>
                        <div class="card-title" id="branch-title"></div>
                        <div class="hint">يمكنك إضافة أبناء لكل أب في هذا الفرع مع العمر والموقع.</div>
                    </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <a href="index.html" class="btn btn-secondary btn-small">الصفحة الرئيسية</a>
                    <button id="logout-btn" class="btn btn-secondary btn-small" type="button">تسجيل الخروج</button>
                </div>
            </div>

            <div class="field">
                <div class="section-title">اختيار الأب</div>
                <select id="parent-select">
                    <option value="">اختر الأب لإضافة أبنائه</option>
                </select>
                <div class="hint">قائمة الآباء الحالية مبدئية ويمكن تطويرها لاحقًا.</div>
            </div>

            <div class="field">
                <div class="section-title">إضافة أبناء</div>
                <div class="grid">
                    <div>
                        <label for="child-name-1">اسم الابن</label>
                        <input id="child-name-1" type="text" placeholder="الاسم الكامل" />
                    </div>
                    <div>
                        <label for="child-hijri-1">تاريخ الميلاد (هجري)</label>
                        <input id="child-hijri-1" type="text" dir="ltr" lang="en" inputmode="numeric" placeholder="1445-09-01" />
                        <div class="hint">الصيغة: YYYY-MM-DD</div>
                    </div>
                    <div>
                        <label for="child-greg-1">تاريخ الميلاد (ميلادي)</label>
                        <input id="child-greg-1" type="date" dir="ltr" lang="en" />
                    </div>
                    <div>
                        <label for="child-city-1">المدينة</label>
                        <input id="child-city-1" type="text" placeholder="المدينة" />
                    </div>
                    <div>
                        <label for="child-area-1">الحي / القرية</label>
                        <input id="child-area-1" type="text" placeholder="حي كذا أو قرية كذا" />
                    </div>
                    <div>
                        <label for="child-deceased-1">الحالة</label>
                        <div style="display:flex; align-items:center; gap:10px; min-height: 38px;">
                            <input id="child-deceased-1" type="checkbox" />
                            <div>متوفى</div>
                        </div>
                    </div>
                </div>
                <div class="hint">يمكنك تكرار الإدخال لنفس الأب أكثر من مرة لإضافة باقي الأبناء.</div>
                <button id="add-child-btn" class="btn btn-primary" type="button" style="margin-top: 8px;">حفظ بيانات الابن</button>
                <div id="child-alert" class="alert" style="display: none;"></div>
            </div>

            <div id="edit-child-card" class="field" style="display: none;">
                <div class="section-title">تعديل بيانات</div>
                <div id="edit-child-name" class="hint"></div>
                <div class="grid">
                    <div>
                        <label for="edit-child-hijri">تاريخ الميلاد (هجري)</label>
                        <input id="edit-child-hijri" type="text" dir="ltr" lang="en" inputmode="numeric" placeholder="1445-09-01" />
                        <div class="hint">الصيغة: YYYY-MM-DD</div>
                    </div>
                    <div>
                        <label for="edit-child-greg">تاريخ الميلاد (ميلادي)</label>
                        <input id="edit-child-greg" type="date" dir="ltr" lang="en" />
                    </div>
                    <div>
                        <label for="edit-child-city">المدينة</label>
                        <input id="edit-child-city" type="text" placeholder="المدينة" />
                    </div>
                    <div>
                        <label for="edit-child-area">الحي / القرية</label>
                        <input id="edit-child-area" type="text" placeholder="حي كذا أو قرية كذا" />
                    </div>
                    <div>
                        <label for="edit-child-deceased">الحالة</label>
                        <div style="display:flex; align-items:center; gap:10px; min-height: 38px;">
                            <input id="edit-child-deceased" type="checkbox" />
                            <div>متوفى</div>
                        </div>
                    </div>
                </div>
                <div style="display:flex; gap:8px; flex-wrap: wrap; margin-top: 8px;">
                    <button id="save-edit-btn" class="btn btn-primary" type="button">حفظ التعديل</button>
                    <button id="cancel-edit-btn" class="btn btn-secondary" type="button">إلغاء</button>
                </div>
                <div id="edit-child-alert" class="alert" style="display: none; margin-top: 8px;"></div>
            </div>

            <div class="field">
                <div class="section-title">أبناء الأب المختار</div>
                <div id="children-container" class="children-list"></div>
            </div>
        </div>

        <div id="events-card" class="card" style="display: none;">
            <div class="card-header">
                <div>
                    <div class="card-title">المناسبات</div>
                    <div class="hint">الأفراح والمناسبات السعيدة، المرضى، والوفيات.</div>
                </div>
            </div>

            <details class="toggle-card" data-kind="happy">
                <summary>
                    <div class="toggle-title">
                        <span class="toggle-icon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#047857" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2l1.5 5.3L19 9l-5.5 1.7L12 16l-1.5-5.3L5 9l5.5-1.7L12 2z"></path>
                            </svg>
                        </span>
                        <span class="toggle-title-text">
                            <span class="toggle-title-main">الأفراح والمناسبات السعيدة</span>
                            <span class="toggle-title-sub">مولود، خطوبة، زواج، تخرج…</span>
                        </span>
                    </div>
                    <span class="toggle-chevron" aria-hidden="true">›</span>
                </summary>
                <div class="toggle-body">
                    <div class="grid">
                        <div class="field">
                            <label for="happy-type">نوع المناسبة</label>
                            <select id="happy-type">
                                <option value="">اختر نوع المناسبة</option>
                                <option value="birth">مولود جديد</option>
                                <option value="engagement">خطوبة</option>
                                <option value="contract">عقد قران</option>
                                <option value="marriage">زواج</option>
                                <option value="graduation">تخرج</option>
                                <option value="success">نجاح / تفوق</option>
                                <option value="promotion">ترقية / وظيفة</option>
                                <option value="new_house">منزل جديد</option>
                                <option value="travel">سفر</option>
                                <option value="gathering">اجتماع عائلي</option>
                            </select>
                        </div>
                        <div class="field">
                            <label for="happy-person">اسم الشخص</label>
                            <input id="happy-person" type="text" placeholder="الاسم الكامل" />
                        </div>
                        <div class="field">
                            <label for="happy-date">تاريخ المناسبة</label>
                            <input id="happy-date" type="date" dir="ltr" lang="en" />
                        </div>
                        <div class="field">
                            <label for="happy-visibility-days">مدة عرض الخبر</label>
                            <select id="happy-visibility-days">
                                <option value="1">يوم</option>
                                <option value="2">يومان</option>
                                <option value="3">ثلاثة أيام</option>
                                <option value="4">أربعة أيام</option>
                                <option value="5">خمسة أيام</option>
                                <option value="6">ستة أيام</option>
                                <option value="7" selected>أسبوع</option>
                            </select>
                        </div>
                    </div>
                    <div class="field">
                        <label for="happy-details">تفاصيل (اختياري)</label>
                        <textarea id="happy-details" rows="2" placeholder="مثال: مكان الحفل، الجامعة، أي تفاصيل مهمة…"></textarea>
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap: wrap;">
                        <button id="save-happy-btn" class="btn btn-primary" type="button">إضافة</button>
                        <button id="cancel-happy-btn" class="btn btn-secondary" type="button" style="display:none;">إلغاء التعديل</button>
                    </div>
                    <div id="happy-alert" class="alert" style="display:none;"></div>
                    <div class="field" style="margin-top: 14px;">
                        <div class="section-title">آخر الأفراح</div>
                        <div id="happy-list" class="children-list"></div>
                    </div>
                </div>
            </details>

            <details class="toggle-card" data-kind="sick">
                <summary>
                    <div class="toggle-title">
                        <span class="toggle-icon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#b45309" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 21s-7-4.4-7-11a4 4 0 0 1 7-2 4 4 0 0 1 7 2c0 6.6-7 11-7 11z"></path>
                            </svg>
                        </span>
                        <span class="toggle-title-text">
                            <span class="toggle-title-main">المرضى</span>
                            <span class="toggle-title-sub">في المستشفى أو في المنزل</span>
                        </span>
                    </div>
                    <span class="toggle-chevron" aria-hidden="true">›</span>
                </summary>
                <div class="toggle-body">
                    <div class="grid">
                        <div class="field">
                            <label for="sick-type">نوع الحالة</label>
                            <select id="sick-type">
                                <option value="">اختر النوع</option>
                                <option value="sick">مريض / تنويم</option>
                                <option value="operation">عملية / تنويم</option>
                                <option value="discharge">خروج من المستشفى</option>
                            </select>
                        </div>
                        <div class="field">
                            <label for="sick-person">اسم الشخص</label>
                            <input id="sick-person" type="text" placeholder="الاسم الكامل" />
                        </div>
                        <div class="field">
                            <label for="sick-date">تاريخ الخبر</label>
                            <input id="sick-date" type="date" dir="ltr" lang="en" />
                        </div>
                        <div class="field">
                            <label for="sick-visibility-days">مدة عرض الخبر</label>
                            <select id="sick-visibility-days">
                                <option value="1">يوم</option>
                                <option value="2">يومان</option>
                                <option value="3">ثلاثة أيام</option>
                                <option value="4">أربعة أيام</option>
                                <option value="5">خمسة أيام</option>
                                <option value="6">ستة أيام</option>
                                <option value="7" selected>أسبوع</option>
                            </select>
                        </div>
                    </div>

                    <div class="grid">
                        <div class="field">
                            <label for="sick-place">مكان المريض</label>
                            <select id="sick-place">
                                <option value="hospital">في المستشفى</option>
                                <option value="home">في المنزل</option>
                            </select>
                        </div>
                    </div>

                    <div id="sick-hospital-fields" class="field" style="margin-top: 8px;">
                        <div class="section-title">بيانات المستشفى</div>
                        <div class="grid">
                            <div>
                                <label for="sick-hospital-name">اسم المستشفى</label>
                                <input id="sick-hospital-name" type="text" placeholder="اسم المستشفى" />
                            </div>
                            <div>
                                <label for="sick-hospital-dept">القسم</label>
                                <input id="sick-hospital-dept" type="text" placeholder="مثال: التنويم، العناية، الجراحة..." />
                            </div>
                        </div>
                    </div>

                    <div id="sick-home-fields" class="field" style="display:none; margin-top: 8px;">
                        <div class="section-title">بيانات المنزل</div>
                        <div class="grid">
                            <div>
                                <label for="sick-home-city">المدينة</label>
                                <input id="sick-home-city" type="text" placeholder="المدينة" />
                            </div>
                            <div>
                                <label for="sick-home-area">الحي / الموقع</label>
                                <input id="sick-home-area" type="text" placeholder="الحي أو وصف مختصر للموقع" />
                            </div>
                        </div>
                    </div>

                    <div class="field" style="margin-top: 8px;">
                        <div class="section-title">طريقة الاطمئنان</div>
                        <div class="grid">
                            <div>
                                <label for="sick-contact-method">الطريقة</label>
                                <select id="sick-contact-method">
                                    <option value="visit">زيارة</option>
                                    <option value="call">اتصال</option>
                                    <option value="whatsapp">واتساب</option>
                                </select>
                                <div class="hint">إذا لا يرغب بالزيارة اختر اتصال/واتساب.</div>
                            </div>
                        </div>
                    </div>

                    <div id="sick-visit-block" style="margin-top: 10px;">
                        <div class="section-title">مواعيد الزيارة</div>
                        <div class="grid">
                            <div>
                                <label for="sick-visit-date-from">الزيارة من تاريخ</label>
                                <input id="sick-visit-date-from" type="date" dir="ltr" lang="en" />
                            </div>
                            <div>
                                <label for="sick-visit-date-to">الزيارة إلى تاريخ</label>
                                <input id="sick-visit-date-to" type="date" dir="ltr" lang="en" />
                            </div>
                            <div>
                                <label for="sick-visit-time-from">من الساعة</label>
                                <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
                                    <select id="sick-visit-time-from-hour" dir="ltr" lang="en">
                                        <option value=""></option>
                                        <option value="1">1</option>
                                        <option value="2">2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="5">5</option>
                                        <option value="6">6</option>
                                        <option value="7">7</option>
                                        <option value="8">8</option>
                                        <option value="9">9</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                    </select>
                                    <span dir="ltr">:</span>
                                    <select id="sick-visit-time-from-minute" dir="ltr" lang="en">
                                        <option value=""></option>
                                        <option value="00">00</option>
                                        <option value="01">01</option>
                                        <option value="02">02</option>
                                        <option value="03">03</option>
                                        <option value="04">04</option>
                                        <option value="05">05</option>
                                        <option value="06">06</option>
                                        <option value="07">07</option>
                                        <option value="08">08</option>
                                        <option value="09">09</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                        <option value="13">13</option>
                                        <option value="14">14</option>
                                        <option value="15">15</option>
                                        <option value="16">16</option>
                                        <option value="17">17</option>
                                        <option value="18">18</option>
                                        <option value="19">19</option>
                                        <option value="20">20</option>
                                        <option value="21">21</option>
                                        <option value="22">22</option>
                                        <option value="23">23</option>
                                        <option value="24">24</option>
                                        <option value="25">25</option>
                                        <option value="26">26</option>
                                        <option value="27">27</option>
                                        <option value="28">28</option>
                                        <option value="29">29</option>
                                        <option value="30">30</option>
                                        <option value="31">31</option>
                                        <option value="32">32</option>
                                        <option value="33">33</option>
                                        <option value="34">34</option>
                                        <option value="35">35</option>
                                        <option value="36">36</option>
                                        <option value="37">37</option>
                                        <option value="38">38</option>
                                        <option value="39">39</option>
                                        <option value="40">40</option>
                                        <option value="41">41</option>
                                        <option value="42">42</option>
                                        <option value="43">43</option>
                                        <option value="44">44</option>
                                        <option value="45">45</option>
                                        <option value="46">46</option>
                                        <option value="47">47</option>
                                        <option value="48">48</option>
                                        <option value="49">49</option>
                                        <option value="50">50</option>
                                        <option value="51">51</option>
                                        <option value="52">52</option>
                                        <option value="53">53</option>
                                        <option value="54">54</option>
                                        <option value="55">55</option>
                                        <option value="56">56</option>
                                        <option value="57">57</option>
                                        <option value="58">58</option>
                                        <option value="59">59</option>
                                    </select>
                                    <select id="sick-visit-time-from-period">
                                        <option value=""></option>
                                        <option value="am">صباحاً</option>
                                        <option value="pm">مساءً</option>
                                    </select>
                                    <input id="sick-visit-time-from" type="hidden" />
                                </div>
                            </div>
                            <div>
                                <label for="sick-visit-time-to">إلى الساعة</label>
                                <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
                                    <select id="sick-visit-time-to-hour" dir="ltr" lang="en">
                                        <option value=""></option>
                                        <option value="1">1</option>
                                        <option value="2">2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="5">5</option>
                                        <option value="6">6</option>
                                        <option value="7">7</option>
                                        <option value="8">8</option>
                                        <option value="9">9</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                    </select>
                                    <span dir="ltr">:</span>
                                    <select id="sick-visit-time-to-minute" dir="ltr" lang="en">
                                        <option value=""></option>
                                        <option value="00">00</option>
                                        <option value="01">01</option>
                                        <option value="02">02</option>
                                        <option value="03">03</option>
                                        <option value="04">04</option>
                                        <option value="05">05</option>
                                        <option value="06">06</option>
                                        <option value="07">07</option>
                                        <option value="08">08</option>
                                        <option value="09">09</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                        <option value="13">13</option>
                                        <option value="14">14</option>
                                        <option value="15">15</option>
                                        <option value="16">16</option>
                                        <option value="17">17</option>
                                        <option value="18">18</option>
                                        <option value="19">19</option>
                                        <option value="20">20</option>
                                        <option value="21">21</option>
                                        <option value="22">22</option>
                                        <option value="23">23</option>
                                        <option value="24">24</option>
                                        <option value="25">25</option>
                                        <option value="26">26</option>
                                        <option value="27">27</option>
                                        <option value="28">28</option>
                                        <option value="29">29</option>
                                        <option value="30">30</option>
                                        <option value="31">31</option>
                                        <option value="32">32</option>
                                        <option value="33">33</option>
                                        <option value="34">34</option>
                                        <option value="35">35</option>
                                        <option value="36">36</option>
                                        <option value="37">37</option>
                                        <option value="38">38</option>
                                        <option value="39">39</option>
                                        <option value="40">40</option>
                                        <option value="41">41</option>
                                        <option value="42">42</option>
                                        <option value="43">43</option>
                                        <option value="44">44</option>
                                        <option value="45">45</option>
                                        <option value="46">46</option>
                                        <option value="47">47</option>
                                        <option value="48">48</option>
                                        <option value="49">49</option>
                                        <option value="50">50</option>
                                        <option value="51">51</option>
                                        <option value="52">52</option>
                                        <option value="53">53</option>
                                        <option value="54">54</option>
                                        <option value="55">55</option>
                                        <option value="56">56</option>
                                        <option value="57">57</option>
                                        <option value="58">58</option>
                                        <option value="59">59</option>
                                    </select>
                                    <select id="sick-visit-time-to-period">
                                        <option value=""></option>
                                        <option value="am">صباحاً</option>
                                        <option value="pm">مساءً</option>
                                    </select>
                                    <input id="sick-visit-time-to" type="hidden" />
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="sick-contact-block" style="margin-top: 10px; display: none;">
                        <div class="section-title">بيانات التواصل</div>
                        <div class="grid">
                            <div>
                                <label for="sick-contact-phone">رقم الجوال</label>
                                <input id="sick-contact-phone" type="tel" placeholder="05xxxxxxxx" />
                                <div class="hint">يظهر رقم الجوال فقط لمن لديه الرابط.</div>
                            </div>
                        </div>
                    </div>

                    <div class="field">
                        <label for="sick-notes">ملاحظات (اختياري)</label>
                        <textarea id="sick-notes" rows="2" placeholder="مثال: الدعاء، أي تنبيه للزيارة…"></textarea>
                    </div>

                    <div style="display:flex; gap:8px; flex-wrap: wrap;">
                        <button id="save-sick-btn" class="btn btn-primary" type="button">إضافة</button>
                        <button id="cancel-sick-btn" class="btn btn-secondary" type="button" style="display:none;">إلغاء التعديل</button>
                    </div>
                    <div id="sick-alert" class="alert" style="display:none;"></div>

                    <div class="field" style="margin-top: 14px;">
                        <div class="section-title">آخر أخبار المرضى</div>
                        <div id="sick-list" class="children-list"></div>
                    </div>
                </div>
            </details>

            <details class="toggle-card" data-kind="death">
                <summary>
                    <div class="toggle-title">
                        <span class="toggle-icon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#374151" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2v20"></path>
                                <path d="M5 7h14"></path>
                                <path d="M7 22h10"></path>
                            </svg>
                        </span>
                        <span class="toggle-title-text">
                            <span class="toggle-title-main">الوفيات</span>
                            <span class="toggle-title-sub">بيانات الصلاة والدفن والعزاء وأرقام التواصل</span>
                        </span>
                    </div>
                    <span class="toggle-chevron" aria-hidden="true">›</span>
                </summary>
                <div class="toggle-body">
                    <div class="grid">
                        <div class="field">
                            <label for="death-person">اسم المتوفى</label>
                            <input id="death-person" type="text" placeholder="الاسم الكامل" />
                        </div>
                        <div class="field">
                            <label for="death-date">تاريخ الوفاة</label>
                            <input id="death-date" type="date" dir="ltr" lang="en" />
                        </div>
                        <div class="field">
                            <label for="death-visibility-days">مدة عرض الخبر</label>
                            <select id="death-visibility-days">
                                <option value="1">يوم</option>
                                <option value="2">يومان</option>
                                <option value="3">ثلاثة أيام</option>
                                <option value="4">أربعة أيام</option>
                                <option value="5">خمسة أيام</option>
                                <option value="6">ستة أيام</option>
                                <option value="7" selected>أسبوع</option>
                            </select>
                        </div>
                    </div>
                    <div class="section-title" style="margin-top: 6px;">تفاصيل الصلاة والدفن</div>
                    <div class="grid">
                        <div>
                            <label for="prayer-place">مكان الصلاة</label>
                            <input id="prayer-place" type="text" placeholder="المسجد/المصلى/الموقع" />
                        </div>
                        <div>
                            <label for="prayer-time">وقت الصلاة</label>
                            <input id="prayer-time" type="text" placeholder="مثال: بعد صلاة العصر" />
                        </div>
                        <div>
                            <label for="burial-place">مكان الدفن</label>
                            <input id="burial-place" type="text" placeholder="المقبرة/الموقع" />
                        </div>
                        <div>
                            <label for="burial-time">وقت الدفن</label>
                            <input id="burial-time" type="text" placeholder="مثال: بعد الصلاة مباشرة" />
                        </div>
                    </div>
                    <div class="section-title" style="margin-top: 10px;">تفاصيل العزاء</div>
                    <div class="grid">
                        <div>
                            <label for="condolence-place">موقع العزاء</label>
                            <input id="condolence-place" type="text" placeholder="القاعة/الحي/المدينة" />
                        </div>
                        <div>
                            <label for="condolence-time">وقت العزاء</label>
                            <input id="condolence-time" type="text" placeholder="مثال: من بعد العشاء إلى 11 مساءً" />
                        </div>
                    </div>
                    <div class="section-title" style="margin-top: 10px;">أرقام التواصل</div>
                    <div class="grid">
                        <div>
                            <label for="condolence-phone-1">جوال 1</label>
                            <input id="condolence-phone-1" type="tel" placeholder="05xxxxxxxx" />
                        </div>
                        <div>
                            <label for="condolence-phone-2">جوال 2 (اختياري)</label>
                            <input id="condolence-phone-2" type="tel" placeholder="05xxxxxxxx" />
                        </div>
                    </div>
                    <div class="field">
                        <label for="death-notes">نص الخبر (اختياري)</label>
                        <textarea id="death-notes" rows="2" placeholder="مثال: انتقل إلى رحمة الله... نسأل الله له الرحمة والمغفرة"></textarea>
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap: wrap;">
                        <button id="save-death-btn" class="btn btn-primary" type="button">نشر</button>
                        <button id="cancel-death-btn" class="btn btn-secondary" type="button" style="display:none;">إلغاء التعديل</button>
                    </div>
                    <div id="death-alert" class="alert" style="display: none; margin-top: 8px;"></div>

                    <div class="field" style="margin-top: 14px;">
                        <div class="section-title">آخر أخبار الوفاة</div>
                        <div id="deaths-list" class="children-list"></div>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const parentsByBranch = {
            "زيدان": ["خميس بن زيدان بن مطلق", "عبدالله بن زيدان بن مطلق"],
            "مزيد": ["خميس", "صلف", "صلال"],
            "زايد": [],
            "لاحم": [],
            "ملحم": []
        };

        const state = {
            branch: null,
            children: {},
            happyEvents: [],
            sickEvents: [],
            deaths: [],
            forcedRahmaByBranch: {}
        };
        let desiredParentFromUrl = "";
        let desiredFocusFromUrl = "";

        const FORCED_RAHMA_BY_BASE = {
            "صلف": " (رحمة الله)",
            "صلال": " (رحمه الله)",
            "عرفج": " (رحمه الله)",
            "دليميك": " (رحمه الله)"
        };

        const treeCard = document.getElementById("tree-card");
        const treeTitleEl = document.getElementById("tree-title");
        const treeBranchSelect = document.getElementById("tree-branch");
        const treeList = document.getElementById("tree-list");
        const openDelegateBtn = document.getElementById("open-delegate");
        const loginCard = document.getElementById("login-card");
        const loginBtn = document.getElementById("login-btn");
        const forgotBtn = document.getElementById("forgot-btn");
        const loginAlert = document.getElementById("login-alert");
        const branchSelectLogin = document.getElementById("branch");
        const phoneInput = document.getElementById("phone");
        const emailInput = document.getElementById("email");
        const codeInput = document.getElementById("code");
        const dashboardCard = document.getElementById("dashboard-card");
        const branchTitle = document.getElementById("branch-title");
        const eventsCard = document.getElementById("events-card");
        const parentSelect = document.getElementById("parent-select");
        const childName = document.getElementById("child-name-1");
        const childBirthHijri = document.getElementById("child-hijri-1");
        const childBirthGreg = document.getElementById("child-greg-1");
        const childCity = document.getElementById("child-city-1");
        const childArea = document.getElementById("child-area-1");
        const childDeceased = document.getElementById("child-deceased-1");
        const addChildBtn = document.getElementById("add-child-btn");
        const childAlert = document.getElementById("child-alert");
        const childrenContainer = document.getElementById("children-container");
        const editChildCard = document.getElementById("edit-child-card");
        const editChildName = document.getElementById("edit-child-name");
        const editChildHijri = document.getElementById("edit-child-hijri");
        const editChildGreg = document.getElementById("edit-child-greg");
        const editChildCity = document.getElementById("edit-child-city");
        const editChildArea = document.getElementById("edit-child-area");
        const editChildDeceased = document.getElementById("edit-child-deceased");
        const saveEditBtn = document.getElementById("save-edit-btn");
        const cancelEditBtn = document.getElementById("cancel-edit-btn");
        const editChildAlert = document.getElementById("edit-child-alert");
        const logoutBtn = document.getElementById("logout-btn");
        const happyType = document.getElementById("happy-type");
        const happyPerson = document.getElementById("happy-person");
        const happyDate = document.getElementById("happy-date");
        const happyVisibilityDays = document.getElementById("happy-visibility-days");
        const happyDetails = document.getElementById("happy-details");
        const saveHappyBtn = document.getElementById("save-happy-btn");
        const cancelHappyBtn = document.getElementById("cancel-happy-btn");
        const happyAlert = document.getElementById("happy-alert");
        const happyList = document.getElementById("happy-list");

        const sickType = document.getElementById("sick-type");
        const sickPerson = document.getElementById("sick-person");
        const sickDate = document.getElementById("sick-date");
        const sickVisibilityDays = document.getElementById("sick-visibility-days");
        const sickPlace = document.getElementById("sick-place");
        const sickHospitalFields = document.getElementById("sick-hospital-fields");
        const sickHospitalName = document.getElementById("sick-hospital-name");
        const sickHospitalDept = document.getElementById("sick-hospital-dept");
        const sickHomeFields = document.getElementById("sick-home-fields");
        const sickHomeCity = document.getElementById("sick-home-city");
        const sickHomeArea = document.getElementById("sick-home-area");
        const sickContactMethod = document.getElementById("sick-contact-method");
        const sickVisitBlock = document.getElementById("sick-visit-block");
        const sickVisitDateFrom = document.getElementById("sick-visit-date-from");
        const sickVisitDateTo = document.getElementById("sick-visit-date-to");
        const sickVisitTimeFrom = document.getElementById("sick-visit-time-from");
        const sickVisitTimeTo = document.getElementById("sick-visit-time-to");
        const sickVisitTimeFromHour = document.getElementById("sick-visit-time-from-hour");
        const sickVisitTimeFromMinute = document.getElementById("sick-visit-time-from-minute");
        const sickVisitTimeFromPeriod = document.getElementById("sick-visit-time-from-period");
        const sickVisitTimeToHour = document.getElementById("sick-visit-time-to-hour");
        const sickVisitTimeToMinute = document.getElementById("sick-visit-time-to-minute");
        const sickVisitTimeToPeriod = document.getElementById("sick-visit-time-to-period");
        const sickContactBlock = document.getElementById("sick-contact-block");
        const sickContactPhone = document.getElementById("sick-contact-phone");
        const sickNotes = document.getElementById("sick-notes");
        const saveSickBtn = document.getElementById("save-sick-btn");
        const cancelSickBtn = document.getElementById("cancel-sick-btn");
        const sickAlert = document.getElementById("sick-alert");
        const sickList = document.getElementById("sick-list");

        const deathPerson = document.getElementById("death-person");
        const deathDate = document.getElementById("death-date");
        const deathVisibilityDays = document.getElementById("death-visibility-days");
        const prayerPlace = document.getElementById("prayer-place");
        const prayerTime = document.getElementById("prayer-time");
        const burialPlace = document.getElementById("burial-place");
        const burialTime = document.getElementById("burial-time");
        const condolencePlace = document.getElementById("condolence-place");
        const condolenceTime = document.getElementById("condolence-time");
        const condolencePhone1 = document.getElementById("condolence-phone-1");
        const condolencePhone2 = document.getElementById("condolence-phone-2");
        const deathNotes = document.getElementById("death-notes");
        const saveDeathBtn = document.getElementById("save-death-btn");
        const cancelDeathBtn = document.getElementById("cancel-death-btn");
        const deathAlert = document.getElementById("death-alert");
        const deathsList = document.getElementById("deaths-list");

        function normalizePersonName(v) {
            const s = String(v || "")
                .replace(/\s+/g, " ")
                .trim();
            if (!s) return "";
            const parts = s.split(" ").map((p) => p.trim()).filter(Boolean);
            if (parts.length >= 3 && parts.every((p) => p.length === 1 && /^[\u0600-\u06FF]$/.test(p))) {
                return parts.join("");
            }
            return s;
        }

        function setDeceasedFieldsUiMode(deceased, els) {
            const list = Array.isArray(els) ? els : [];
            list.forEach((el) => {
                if (!el) return;
                const wrap = el.parentElement;
                if (wrap && wrap.style) wrap.style.display = deceased ? "none" : "";
                try {
                    el.disabled = !!deceased;
                    if (deceased) el.value = "";
                } catch (e) {}
            });
        }

        function applyAddDeceasedUiMode() {
            const deceased = !!(childDeceased && childDeceased.checked);
            setDeceasedFieldsUiMode(deceased, [childBirthHijri, childBirthGreg, childCity, childArea]);
        }

        function applyEditDeceasedUiMode() {
            const deceased = !!(editChildDeceased && editChildDeceased.checked);
            setDeceasedFieldsUiMode(deceased, [editChildHijri, editChildGreg, editChildCity, editChildArea]);
            if (editChildName && editingChildRef && editingChildRef.childId) {
                const cid = normalizePersonName(editingChildRef.childId);
                const display = getDisplayNameForNodeId(cid, state.branch ? getBranchRootName(state.branch) : "");
                const forcedSuffix = getForcedRahmaSuffix(cid, state.branch);
                const suffix = forcedSuffix ? forcedSuffix : deceased ? " (رحمه الله)" : "";
                editChildName.textContent = "الاسم: " + (display || cid) + suffix;
            }
        }

        function parseTruthyValue(v) {
            if (v === true) return true;
            if (v === false || v == null) return false;
            if (typeof v === "number") return v === 1;
            const s = String(v).trim().toLowerCase();
            if (!s) return false;
            if (s === "true" || s === "t" || s === "1" || s === "yes" || s === "y" || s === "on") return true;
            if (s === "نعم" || s === "متوفي" || s === "متوفى" || s === "متوفاة" || s === "متوفاه") return true;
            return false;
        }

        function getBranchRootName(branchKey) {
            const k = normalizePersonName(branchKey);
            if (!k) return "";
            return k + " بن مطلق بن زيدان";
        }

        function normalizeParentName(v, branchKey) {
            const raw = normalizePersonName(v || "");
            const cleaned = raw.replace(/^أصل الفرع:\s*/i, "").trim();
            if (!cleaned) return "";
            if (/بن\s+مطلق\s+بن\s+زيدان/.test(cleaned)) return cleaned;
            if (Object.prototype.hasOwnProperty.call(parentsByBranch, cleaned)) return cleaned + " بن مطلق بن زيدان";
            if (branchKey && normalizePersonName(branchKey) === cleaned) return cleaned + " بن مطلق بن زيدان";
            return cleaned;
        }

        function resolveSelectedParentId(selectedParent, branchKey) {
            const s = normalizePersonName(selectedParent || "");
            if (!s) return "";
            if (s.includes("/")) return s;
            const b = normalizePersonName(branchKey || "");
            const branchRoot = b ? getBranchRootName(b) : "";
            if (branchRoot && (s === branchRoot || s === b)) return branchRoot;
            return branchRoot ? (branchRoot + "/" + s) : s;
        }

        function applyView(view) {
            const v = view === "delegate" ? "delegate" : "tree";
            if (treeCard) treeCard.style.display = v === "tree" ? "block" : "none";
            if (loginCard) loginCard.style.display = v === "delegate" ? "block" : "none";
            if (dashboardCard) dashboardCard.style.display = "none";
            if (eventsCard) eventsCard.style.display = "none";
        }

        function renderPublicTree(branchKey, opts) {
            if (!treeList) return;
            treeList.innerHTML = "";
            const key = String(branchKey || "").trim();
            if (!key || !Object.prototype.hasOwnProperty.call(parentsByBranch, key)) {
                const empty = document.createElement("div");
                empty.className = "hint";
                empty.textContent = "اختر الفرع لعرض الشجرة.";
                treeList.appendChild(empty);
                if (treeTitleEl) treeTitleEl.textContent = "شجرة العائلة";
                return;
            }
            const requestedFocus = normalizePersonName(opts && opts.focus ? String(opts.focus) : "");
            if (treeTitleEl) treeTitleEl.textContent = "شجرة فرع " + key + " بن مطلق بن زيدان";
            const staticParents = parentsByBranch[key] || [];
            const loading = document.createElement("div");
            loading.className = "hint";
            loading.textContent = "جاري تحميل بيانات الأبناء...";
            treeList.appendChild(loading);
            loadChildrenForBranch(key, { applyToState: false })
                .then((res) => {
                    treeList.innerHTML = "";
                    if (!res.ok) {
                        const err = document.createElement("div");
                        err.className = "alert alert-error";
                        if (res.reason === "not_configured") err.textContent = "تعذر تحميل البيانات لأن الربط غير مُعد.";
                        else err.textContent = formatTreeChildrenDbError(res.error, "load");
                        treeList.appendChild(err);
                        return;
                    }
                    if (res.capabilities && res.capabilities.deceased === false) {
                        const warn = document.createElement("div");
                        warn.className = "alert alert-error";
                        const hint = res.capabilities && res.capabilities.deceased_hint ? String(res.capabilities.deceased_hint) : "";
                        if (hint === "schema_cache") {
                            warn.textContent =
                                "تعذر تحميل حالة الوفاة لأن Supabase لم يُحدّث المخطط بعد. انتظر دقيقة ثم حدّث الصفحة، أو نفّذ Reload schema cache من لوحة Supabase.";
                        } else if (hint === "rls") {
                            warn.textContent =
                                "تعذر تحميل حالة الوفاة لأن RLS تمنع القراءة من جدول tree_children. فعّل سياسة SELECT لدور anon ثم أعد المحاولة.";
                        } else if (hint === "permission") {
                            warn.textContent =
                                "تعذر تحميل حالة الوفاة لأن دور anon لا يملك صلاحية SELECT على جدول tree_children. امنح الصلاحية ثم أعد المحاولة.";
                        } else {
                            warn.textContent =
                                "تعذر تحميل حالة الوفاة (رحمه الله) من Supabase. تحقق من الأعمدة/الصلاحيات ثم أعد المحاولة.";
                        }
                        treeList.appendChild(warn);
                    }
                    const byParent = res.map || {};
                    const branchRoot = getBranchRootName(key);
                    const staticParentIds = [];
                    const metaById = new Map();
                    Object.values(byParent || {}).forEach((list) => {
                        const items = Array.isArray(list) ? list : [];
                        items.forEach((c) => {
                            const id = normalizePersonName(c && c.name ? c.name : "");
                            if (!id) return;
                            const prev = metaById.get(id);
                            if (!prev) {
                                metaById.set(id, { ...(c || {}), name: id });
                                return;
                            }
                            const merged = { ...(prev || {}), name: id };
                            if (!merged.year && c && c.year) merged.year = String(c.year);
                            if (!merged.gdate && c && c.gdate) merged.gdate = String(c.gdate);
                            if (!merged.hdate && c && c.hdate) merged.hdate = String(c.hdate);
                            if (!merged.city && c && c.city) merged.city = String(c.city);
                            if (!merged.area && c && c.area) merged.area = String(c.area);
                            if (!merged.deceased && c && c.deceased) merged.deceased = true;
                            metaById.set(id, merged);
                        });
                    });

                    const parentsFromData = Object.keys(byParent || {}).map(normalizePersonName).filter(Boolean);
                    const allNodes = new Set(parentsFromData);
                    const inDegree = new Map();
                    parentsFromData.forEach((p) => inDegree.set(p, 0));
                    parentsFromData.forEach((p) => {
                        const list = byParent[p] || [];
                        (Array.isArray(list) ? list : []).forEach((c) => {
                            const cn = normalizePersonName(c && c.name ? c.name : "");
                            if (!cn) return;
                            allNodes.add(cn);
                            inDegree.set(cn, (inDegree.get(cn) || 0) + 1);
                            if (!inDegree.has(p)) inDegree.set(p, 0);
                        });
                    });

                    const roots = [];
                    const seenRoots = new Set();
                    const pushRoot = (n) => {
                        const k = normalizePersonName(n);
                        if (!k || seenRoots.has(k)) return;
                        seenRoots.add(k);
                        roots.push(k);
                    };
                    if (branchRoot) pushRoot(branchRoot);
                    parentsFromData.forEach((p) => {
                        if ((inDegree.get(p) || 0) === 0) pushRoot(p);
                    });
                    if (!roots.length) parentsFromData.forEach(pushRoot);

                    if (!roots.length) {
                        const empty = document.createElement("div");
                        empty.className = "hint";
                        empty.textContent = "لا توجد أسماء مسجلة في هذا الفرع بعد.";
                        treeList.appendChild(empty);
                        return;
                    }

                    const nodeExistsInTree = (nodeId) => {
                        const n = normalizePersonName(nodeId);
                        if (!n) return false;
                        if (Object.prototype.hasOwnProperty.call(byParent, n)) return true;
                        const lists = Object.values(byParent || {});
                        for (let i = 0; i < lists.length; i++) {
                            const list = Array.isArray(lists[i]) ? lists[i] : [];
                            for (let j = 0; j < list.length; j++) {
                                const cid = normalizePersonName(list[j] && list[j].name ? list[j].name : "");
                                if (cid === n) return true;
                            }
                        }
                        return false;
                    };

                    const focusId = requestedFocus && nodeExistsInTree(requestedFocus) ? requestedFocus : "";
                    if (focusId && treeTitleEl) {
                        const focusDisplay = getDisplayNameForNodeId(focusId, branchRoot);
                        const focusIsBranchRoot = branchRoot && normalizePersonName(focusId) === normalizePersonName(branchRoot);
                        const focusSuffix = focusIsBranchRoot ? " (رحمهم الله)" : getForcedRahmaSuffix(focusId, key);
                        treeTitleEl.textContent = "شجرة " + focusDisplay + focusSuffix;
                    }
                    if (focusId) {
                        const backWrap = document.createElement("div");
                        backWrap.style.marginBottom = "10px";
                        const backLink = document.createElement("a");
                        backLink.className = "btn btn-secondary btn-small";
                        backLink.href = "alzidan-tree.html?branch=" + encodeURIComponent(key);
                        backLink.textContent = "عرض الفرع كامل";
                        backWrap.appendChild(backLink);
                        treeList.appendChild(backWrap);
                    }

                    const makeAddLink = (personName) => {
                        const a = document.createElement("a");
                        a.className = "btn btn-secondary btn-small";
                        a.textContent = "إضافة أبناء";
                        a.href =
                            "alzidan-tree.html?view=delegate&branch=" +
                            encodeURIComponent(key) +
                            "&parent=" +
                            encodeURIComponent(personName);
                        return a;
                    };

                    const renderNode = (nodeId, meta, depth, pathSet, mountEl) => {
                        const person = normalizePersonName(nodeId);
                        if (!person) return;
                        const mount = mountEl || treeList;
                        const depthPx = Math.min(56, Math.max(0, depth) * 18);
                        const hasCycle = pathSet && pathSet.has(person);
                        const children = byParent[person] || [];
                        const canExpand = !hasCycle && Array.isArray(children) && children.length;
                        const effectiveMeta = meta || metaById.get(person) || null;

                        const host = canExpand ? document.createElement("details") : null;
                        if (host) {
                            host.className = "tree-node";
                            if (depthPx) host.style.marginRight = depthPx + "px";
                            if (depth === 0 && focusId && person === focusId) host.open = true;
                        }

                        const headerRow = document.createElement("div");
                        headerRow.className = "parent-row";
                        if (!host && depthPx) headerRow.style.marginRight = depthPx + "px";
                        headerRow.style.cursor = "pointer";
                        headerRow.addEventListener("click", (e) => {
                            if (e && typeof e.preventDefault === "function") e.preventDefault();
                            if (e && typeof e.stopPropagation === "function") e.stopPropagation();
                            if (e && e.target && typeof e.target.closest === "function") {
                                if (e.target.closest("a,button")) return;
                            }
                            window.location.href =
                                "alzidan-tree.html?branch=" + encodeURIComponent(key) + "&focus=" + encodeURIComponent(person);
                        });

                        const title = document.createElement("div");
                        title.className = "parent-name";
                        const displayName = getDisplayNameForNodeId(person, branchRoot);
                        const isBranchRootNode = branchRoot && normalizePersonName(person) === normalizePersonName(branchRoot);
                    const forcedSuffix = getForcedRahmaSuffix(person, key);
                    const suffix = isBranchRootNode ? " (رحمهم الله)" : forcedSuffix ? forcedSuffix : (effectiveMeta && effectiveMeta.deceased) ? " (رحمه الله)" : "";
                    title.textContent = displayName + suffix;
                    headerRow.appendChild(title);

                    const actions = document.createElement("div");
                    actions.style.display = "inline-flex";
                    actions.style.alignItems = "center";
                    actions.style.gap = "6px";

                    const isDeceased = !!(effectiveMeta && effectiveMeta.deceased);
                    if (!isDeceased) {
                        const badge = document.createElement("span");
                        badge.className = "badge";
                        const ageText = calculateAge(effectiveMeta || {});
                        const parts = [];
                        if (ageText) parts.push("العمر: " + ageText);
                        parts.push("الأبناء: " + String(Array.isArray(children) ? children.length : 0));
                        badge.textContent = parts.join(" – ");
                        actions.appendChild(badge);
                    }
                    actions.appendChild(makeAddLink(person));
                    headerRow.appendChild(actions);

                        if (canExpand) {
                            const summary = document.createElement("summary");
                            summary.appendChild(headerRow);
                            host.appendChild(summary);

                            const childrenWrap = document.createElement("div");
                            childrenWrap.className = "tree-node-children";
                            host.appendChild(childrenWrap);

                            const nextPath = new Set(pathSet ? Array.from(pathSet) : []);
                            nextPath.add(person);

                            children.forEach((child) => {
                                const childId = normalizePersonName(child && child.name ? child.name : "");
                                if (!childId) return;
                                renderNode(childId, child, depth + 1, nextPath, childrenWrap);
                            });

                            mount.appendChild(host);
                        } else {
                            mount.appendChild(headerRow);
                        }
                    };
                    const visited = new Set();
                    const orderedRoots = focusId ? [focusId] : roots;
                    orderedRoots.forEach((r) => {
                        const k = normalizePersonName(r);
                        if (!k || visited.has(k)) return;
                        visited.add(k);
                        renderNode(k, null, 0, new Set(), treeList);
                    });
                    if (!focusId) {
                        parentsFromData.forEach((p) => {
                            const k = normalizePersonName(p);
                            if (!k || visited.has(k)) return;
                            visited.add(k);
                            renderNode(k, null, 0, new Set(), treeList);
                        });
                        staticParentIds.forEach((p) => {
                            const k = normalizePersonName(p);
                            if (!k || visited.has(k)) return;
                            visited.add(k);
                            renderNode(k, null, 0, new Set(), treeList);
                        });
                    }
                })
                .catch(() => {
                    treeList.innerHTML = "";
                    const err = document.createElement("div");
                    err.className = "alert alert-error";
                    err.textContent = "تعذر تحميل بيانات الأبناء.";
                    treeList.appendChild(err);
                });
        }

        (function initViewFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const view = params.get("view") || "tree";
            const branchKey = params.get("branch") || "";
            desiredParentFromUrl = String(params.get("parent") || "").trim();
            desiredFocusFromUrl = String(params.get("focus") || params.get("f") || "").trim();
            applyView(view);
            if (treeBranchSelect && branchKey) {
                if (Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) {
                    treeBranchSelect.value = branchKey;
                }
            }
            renderPublicTree(treeBranchSelect ? treeBranchSelect.value : "", { focus: desiredFocusFromUrl });
            if (branchSelectLogin && branchKey) {
                if (Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) {
                    branchSelectLogin.value = branchKey;
                }
            }
        })();

        if (treeBranchSelect) {
            treeBranchSelect.addEventListener("change", () => {
                const key = String(treeBranchSelect.value || "").trim();
                desiredFocusFromUrl = "";
                renderPublicTree(key, { focus: "" });
            });
        }

        if (openDelegateBtn) {
            openDelegateBtn.addEventListener("click", () => {
                applyView("delegate");
                if (loginCard && typeof loginCard.scrollIntoView === "function") {
                    loginCard.scrollIntoView({ behavior: "smooth", block: "start" });
                }
            });
        }

        function normalizePhone(v) {
            const digits = String(v || "").replace(/[^\d]/g, "").trim();
            if (!digits) return "";
            if (digits.startsWith("966") && digits.length === 12 && digits[3] === "5") {
                return "0" + digits.slice(3);
            }
            if (digits.startsWith("5") && digits.length === 9) {
                return "0" + digits;
            }
            if (digits.startsWith("05") && digits.length === 10) {
                return digits;
            }
            return digits;
        }

        function normalizeEmail(v) {
            return String(v || "").trim().toLowerCase();
        }

        const DELEGATE_SESSION_KEY = "alzidan_delegate_session_v1";

        function readDelegateSessionRaw() {
            try {
                const rawLocal = localStorage.getItem(DELEGATE_SESSION_KEY);
                if (rawLocal) return { raw: rawLocal, source: "local" };
            } catch (e) {}
            try {
                const rawSession = sessionStorage.getItem(DELEGATE_SESSION_KEY);
                if (rawSession) return { raw: rawSession, source: "session" };
            } catch (e) {}
            return { raw: "", source: "" };
        }

        function writeDelegateSessionRaw(raw) {
            try {
                localStorage.setItem(DELEGATE_SESSION_KEY, raw);
            } catch (e) {}
            try {
                sessionStorage.setItem(DELEGATE_SESSION_KEY, raw);
            } catch (e) {}
        }

        function loadDelegateSession() {
            try {
                const read = readDelegateSessionRaw();
                const raw = read.raw;
                if (!raw) return null;
                const data = JSON.parse(raw);
                if (!data || typeof data !== "object") return null;
                const branch = String(data.branch || "").trim();
                const phone = normalizePhone(String(data.phone || ""));
                const email = normalizeEmail(String(data.email || ""));
                const secret = String(data.secret || "").trim();
                if (!branch || !Object.prototype.hasOwnProperty.call(parentsByBranch, branch)) return null;
                if (!phone || phone.length < 9) return null;
                if (!email || !email.includes("@")) return null;
                if (!secret || secret.length < 4) return null;
                if (read.source === "session") writeDelegateSessionRaw(JSON.stringify({ ...data, branch, phone, email, secret }));
                return { branch, phone, email, secret };
            } catch (e) {
                return null;
            }
        }

        function saveDelegateSession(branchKey, phone, email, secret) {
            try {
                const branch = String(branchKey || "").trim();
                const payload = {
                    branch,
                    phone: normalizePhone(phone),
                    email: normalizeEmail(email),
                    secret: String(secret || "").trim(),
                    savedAt: new Date().toISOString()
                };
                writeDelegateSessionRaw(JSON.stringify(payload));
            } catch (e) {}
        }

        function clearDelegateSession() {
            try {
                localStorage.removeItem(DELEGATE_SESSION_KEY);
            } catch (e) {}
            try {
                sessionStorage.removeItem(DELEGATE_SESSION_KEY);
            } catch (e) {}
        }

        const SUPABASE_URL = "https://wbskjfdqpugnwvrykqcn.supabase.co";
        const SUPABASE_ANON_KEY = "sb_publishable_JhgwBIXhs6z4yBZOoE2EqA_UlzjzW9c";
        const FAMILY_TREE_CHILDREN_TABLE = "tree_children";
        let sbClient = null;

        function getSupabaseClient() {
            if (sbClient) return sbClient;
            const url = String(SUPABASE_URL || "").trim();
            const anonKey = String(SUPABASE_ANON_KEY || "").trim();
            if (!url || !anonKey) return null;
            if (!window.supabase || typeof window.supabase.createClient !== "function") return null;
            sbClient = window.supabase.createClient(url, anonKey);
            return sbClient;
        }

        async function sha256Hex(text) {
            try {
                if (!window.crypto || !window.crypto.subtle) return null;
                const enc = new TextEncoder();
                const buf = await window.crypto.subtle.digest("SHA-256", enc.encode(String(text || "")));
                return Array.from(new Uint8Array(buf))
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");
            } catch (e) {
                return null;
            }
        }

        function makeRequestId() {
            const part1 = Math.random().toString(36).slice(2, 6).toUpperCase();
            const part2 = Math.random().toString(36).slice(2, 6).toUpperCase();
            return "REQ-" + part1 + "-" + part2;
        }

        function duplicateFieldsText(fields) {
            const f = Array.isArray(fields) ? fields : [];
            const hasPhone = f.includes("phone");
            const hasEmail = f.includes("email");
            if (hasPhone && hasEmail) return "الجوال والإيميل مسجلين مسبقًا";
            if (hasPhone) return "رقم الجوال مسجل مسبقًا";
            if (hasEmail) return "الإيميل مسجل مسبقًا";
            return "البيانات مسجلة مسبقًا";
        }

        function phoneCandidates(phone) {
            const raw = String(phone || "").trim();
            if (!raw) return [];
            const digits = raw.replace(/[^\d]/g, "");
            if (!digits) return [];
            const set = new Set([digits, raw]);
            const add966 = (nine) => {
                if (!nine || nine.length !== 9) return;
                set.add("0" + nine);
                set.add(nine);
                set.add("966" + nine);
                set.add("+966" + nine);
            };
            if (digits.startsWith("0") && digits.length === 10 && digits[1] === "5") {
                add966(digits.slice(1));
            } else if (digits.startsWith("966") && digits.length === 12 && digits[3] === "5") {
                add966(digits.slice(3));
            } else if (digits.startsWith("5") && digits.length === 9) {
                add966(digits);
            }
            return Array.from(set).filter(Boolean);
        }

        function fallbackCopyText(text) {
            const el = document.createElement("textarea");
            el.value = text;
            el.setAttribute("readonly", "");
            el.style.position = "fixed";
            el.style.opacity = "0";
            el.style.left = "-9999px";
            document.body.appendChild(el);
            el.select();
            try {
                document.execCommand("copy");
            } catch (e) {}
            document.body.removeChild(el);
        }

        async function copyText(text) {
            try {
                if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (e) {}
            fallbackCopyText(text);
            return true;
        }

        const NOTIFY_EMAIL_TO = "info@alzidan.org";
        function maybeOpenEmailDraft(subject, body) {
            const to = String(NOTIFY_EMAIL_TO || "").trim();
            if (!to || !to.includes("@")) return false;
            const s = encodeURIComponent(String(subject || "").trim());
            const b = encodeURIComponent(String(body || "").trim());
            const url = "mailto:" + encodeURIComponent(to) + (s || b ? `?subject=${s}&body=${b}` : "");
            try {
                window.open(url, "_blank", "noopener,noreferrer");
                return true;
            } catch (e) {
                return false;
            }
        }

        function setLoginAlert(type, text) {
            if (!loginAlert) return;
            loginAlert.className = "alert " + (type === "success" ? "alert-success" : "alert-error");
            loginAlert.textContent = text;
            loginAlert.style.display = "block";
        }

        function hideLoginAlert() {
            if (!loginAlert) return;
            loginAlert.style.display = "none";
            loginAlert.textContent = "";
            loginAlert.className = "alert";
        }

        function buildDelegateRequestMessage(payload) {
            const lines = [];
            lines.push("طلب دخول لشجرة العائلة (مندوب فرع)");
            lines.push("رقم الطلب: " + payload.requestId);
            lines.push("الفرع: " + (payload.branch || ""));
            lines.push("الجوال: " + (payload.phone || ""));
            lines.push("الايميل: " + (payload.email || ""));
            lines.push("الرقم السري: " + (payload.secret || ""));
            lines.push("التاريخ: " + new Date(payload.createdAt).toLocaleString("ar-SA"));
            return lines.join("\n");
        }

        function parseISODate(v) {
            const s = String(v || "").trim();
            const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
            if (!m) return null;
            const y = parseInt(m[1], 10);
            const mo = parseInt(m[2], 10);
            const d = parseInt(m[3], 10);
            if (!y || !mo || !d) return null;
            if (mo < 1 || mo > 12) return null;
            if (d < 1 || d > 31) return null;
            return { y, mo, d };
        }

        const umalquraFormatter = (function () {
            try {
                return new Intl.DateTimeFormat("en-US-u-ca-islamic-umalqura", {
                    timeZone: "UTC",
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit"
                });
            } catch (e) {
                return null;
            }
        })();

        function umalquraHijriPartsFromDate(date) {
            if (!umalquraFormatter || !date) return null;
            const parts = umalquraFormatter.formatToParts(date);
            const get = (t) => {
                const p = parts.find((x) => x.type === t);
                return p ? p.value : "";
            };
            const y = parseInt(get("year"), 10);
            const mo = parseInt(get("month"), 10);
            const d = parseInt(get("day"), 10);
            if (!y || !mo || !d) return null;
            return { y, mo, d };
        }

        function pad2(v) {
            return String(v).padStart(2, "0");
        }

        function formatISODate(parts) {
            if (!parts) return "";
            const y = String(parts.y || "").padStart(4, "0");
            const mo = pad2(parts.mo);
            const d = pad2(parts.d);
            if (!y || !mo || !d) return "";
            return y + "-" + mo + "-" + d;
        }

        function ageYearsFromGregorianDate(dateISO) {
            const parsed = parseISODate(dateISO);
            if (!parsed) return null;
            const now = new Date();
            let age = now.getFullYear() - parsed.y;
            const month = now.getMonth() + 1;
            const day = now.getDate();
            if (month < parsed.mo || (month === parsed.mo && day < parsed.d)) age -= 1;
            if (age < 0 || age > 120) return null;
            return age;
        }

        function gregorianToJdn(y, m, d) {
            const a = Math.floor((14 - m) / 12);
            const y2 = y + 4800 - a;
            const m2 = m + 12 * a - 3;
            return (
                d +
                Math.floor((153 * m2 + 2) / 5) +
                365 * y2 +
                Math.floor(y2 / 4) -
                Math.floor(y2 / 100) +
                Math.floor(y2 / 400) -
                32045
            );
        }

        function jdnToGregorian(jdn) {
            const a = jdn + 32044;
            const b = Math.floor((4 * a + 3) / 146097);
            const c = a - Math.floor((146097 * b) / 4);
            const d = Math.floor((4 * c + 3) / 1461);
            const e = c - Math.floor((1461 * d) / 4);
            const m = Math.floor((5 * e + 2) / 153);
            const day = e - Math.floor((153 * m + 2) / 5) + 1;
            const month = m + 3 - 12 * Math.floor(m / 10);
            const year = 100 * b + d - 4800 + Math.floor(m / 10);
            return { y: year, mo: month, d: day };
        }

        function parseHijriISO(v) {
            const s = String(v || "").trim();
            const m = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s);
            if (!m) return null;
            const y = parseInt(m[1], 10);
            const mo = parseInt(m[2], 10);
            const d = parseInt(m[3], 10);
            if (!y || !mo || !d) return null;
            if (mo < 1 || mo > 12) return null;
            if (d < 1 || d > 30) return null;
            if (y < 1200 || y > 1700) return null;
            return { y, mo, d };
        }

        function hijriToJdn(y, m, d) {
            return (
                d +
                Math.ceil(29.5 * (m - 1)) +
                (y - 1) * 354 +
                Math.floor((3 + 11 * y) / 30) +
                1948439 -
                1
            );
        }

        function jdnToHijri(jdn) {
            const y = Math.floor((30 * (jdn - 1948439) + 10646) / 10631);
            const firstDay = hijriToJdn(y, 1, 1);
            let m = Math.min(12, Math.ceil((jdn - firstDay + 1) / 29.5) + 1);
            if (m < 1) m = 1;
            if (m > 12) m = 12;
            let d = jdn - hijriToJdn(y, m, 1) + 1;
            if (d < 1) {
                m = Math.max(1, m - 1);
                d = jdn - hijriToJdn(y, m, 1) + 1;
            }
            if (d > 30) d = 30;
            return { y, mo: m, d };
        }

        function hijriToGregorianISO(hijriISO) {
            const h = parseHijriISO(hijriISO);
            if (!h) return "";
            const approx = jdnToGregorian(hijriToJdn(h.y, h.mo, h.d));
            if (umalquraFormatter && approx) {
                const base = Date.UTC(approx.y, approx.mo - 1, approx.d, 12, 0, 0);
                const match = (date) => {
                    const got = umalquraHijriPartsFromDate(date);
                    return got && got.y === h.y && got.mo === h.mo && got.d === h.d;
                };
                for (let delta = -10; delta <= 10; delta++) {
                    const date = new Date(base + delta * 86400000);
                    if (!match(date)) continue;
                    return formatISODate({ y: date.getUTCFullYear(), mo: date.getUTCMonth() + 1, d: date.getUTCDate() });
                }
            }
            return formatISODate(approx);
        }

        function gregorianToHijriISO(gregISO) {
            const g = parseISODate(gregISO);
            if (!g) return "";
            if (umalquraFormatter) {
                const date = new Date(Date.UTC(g.y, g.mo - 1, g.d, 12, 0, 0));
                const parts = umalquraHijriPartsFromDate(date);
                if (parts) return formatISODate(parts);
            }
            const jdn = gregorianToJdn(g.y, g.mo, g.d);
            return formatISODate(jdnToHijri(jdn));
        }

        function normalizeHijriDateISO(v) {
            const h = parseHijriISO(v);
            if (!h) return "";
            return formatISODate(h);
        }

        function normalizeGregorianDateISO(v) {
            const g = parseISODate(v);
            if (!g) return "";
            return formatISODate(g);
        }

        function ageYearsFromHijriYear(year) {
            const y = parseInt(String(year || ""), 10);
            if (!y) return null;
            if (y < 1200 || y > 1700) return null;
            const gIso = hijriToGregorianISO(String(y) + "-01-01");
            const parsed = parseISODate(gIso);
            const g = parsed ? { y: parsed.y } : jdnToGregorian(hijriToJdn(y, 1, 1));
            const currentYear = new Date().getFullYear();
            const age = currentYear - g.y;
            if (age < 0 || age > 120) return null;
            return age;
        }

        function calculateAge(meta) {
            const g = meta && meta.gdate ? String(meta.gdate) : "";
            const h = meta && meta.hdate ? String(meta.hdate) : "";
            const y = meta && meta.year != null ? String(meta.year) : "";
            const ageYears =
                ageYearsFromGregorianDate(g) ??
                ageYearsFromGregorianDate(hijriToGregorianISO(h)) ??
                ageYearsFromHijriYear(y);
            if (ageYears == null) return "";
            return String(ageYears) + " سنة";
        }

        function normalizeBirthYear(v) {
            const raw = String(v || "").trim();
            if (!raw) return null;
            const n = Number(raw);
            if (!Number.isFinite(n)) return null;
            const year = Math.trunc(n);
            if (year < 1300 || year > 1600) return null;
            return year;
        }

        let isSyncingBirthDates = false;
        function syncBirthFromHijri() {
            if (!childBirthHijri || !childBirthGreg) return;
            if (isSyncingBirthDates) return;
            const hijriISO = normalizeHijriDateISO(childBirthHijri.value);
            if (!hijriISO) return;
            const gregISO = hijriToGregorianISO(hijriISO);
            if (!gregISO) return;
            isSyncingBirthDates = true;
            childBirthHijri.value = hijriISO;
            childBirthGreg.value = gregISO;
            isSyncingBirthDates = false;
        }

        function syncBirthFromGreg() {
            if (!childBirthHijri || !childBirthGreg) return;
            if (isSyncingBirthDates) return;
            const gregISO = normalizeGregorianDateISO(childBirthGreg.value);
            if (!gregISO) return;
            const hijriISO = gregorianToHijriISO(gregISO);
            if (!hijriISO) return;
            isSyncingBirthDates = true;
            childBirthGreg.value = gregISO;
            childBirthHijri.value = hijriISO;
            isSyncingBirthDates = false;
        }

        if (childBirthHijri) {
            childBirthHijri.addEventListener("input", () => {
                syncBirthFromHijri();
            });
            childBirthHijri.addEventListener("blur", () => {
                syncBirthFromHijri();
            });
        }
        if (childBirthGreg) {
            childBirthGreg.addEventListener("change", () => {
                syncBirthFromGreg();
            });
        }

        function setChildAlert(type, text) {
            if (!childAlert) return;
            childAlert.textContent = text || "";
            childAlert.className = "alert " + (type === "success" ? "alert-success" : "alert-error");
            childAlert.style.display = "block";
        }

        function setEditChildAlert(type, text) {
            if (!editChildAlert) return;
            editChildAlert.textContent = text || "";
            editChildAlert.className = "alert " + (type === "success" ? "alert-success" : "alert-error");
            editChildAlert.style.display = "block";
        }

        function hideEditChildAlert() {
            if (!editChildAlert) return;
            editChildAlert.style.display = "none";
            editChildAlert.textContent = "";
            editChildAlert.className = "alert";
        }

        function formatTreeChildrenDbError(err, action) {
            const a = action === "save" ? "save" : action === "update" ? "update" : action === "delete" ? "delete" : "load";
            const codeRaw = err && err.code != null ? String(err.code) : "";
            const msgRaw = err && err.message != null ? String(err.message) : "";
            const detailsRaw = err && err.details != null ? String(err.details) : "";
            const lowCode = codeRaw.trim().toLowerCase();
            const lowMsg = msgRaw.trim().toLowerCase();
            const lowDetails = detailsRaw.trim().toLowerCase();
            const tableName = "tree_children";

            if (lowMsg === "missing key") {
                if (a === "update" || a === "delete") return "تعذر تنفيذ العملية لأن بيانات الفرع/الأب/الابن غير مكتملة. حدّث الصفحة وحاول مرة أخرى.";
            }

            if (lowMsg === "row not found") {
                if (a === "update") return "تعذر حفظ التعديل لأن السجل غير موجود (قد يكون الاسم تغيّر أو تم حذفه). حدّث الصفحة ثم حاول مرة أخرى.";
                if (a === "delete") return "تعذر الحذف لأن السجل غير موجود (قد يكون الاسم تغيّر أو تم حذفه). حدّث الصفحة ثم حاول مرة أخرى.";
            }

            if (lowMsg === "no_session") {
                return "يلزم تسجيل دخول المندوب أولاً.";
            }

            if (lowMsg === "hash_failed") {
                return "تعذر التحقق من الرقم السري على هذا الجهاز. جرّب متصفحاً آخر أو حدّث الصفحة.";
            }

            if (lowMsg === "not allowed") {
                return "غير مصرح لك بتنفيذ هذه العملية. تأكد أن طلبك كمندوب تم اعتماده وأن البيانات صحيحة.";
            }

            if (lowMsg.includes("no unique or exclusion constraint matching the on conflict specification")) {
                return "تعذر الحفظ بسبب إعداد قديم في Supabase يستخدم ON CONFLICT بدون مفتاح فريد. افتح صفحة الإدارة (admin.html) وانسخ SQL الخاص بالشجرة ثم نفّذه في Supabase ليتم تحديث الدوال.";
            }

            const isSchemaCache =
                lowMsg.includes("schema cache") || lowMsg.includes("could not find the table") || lowDetails.includes("schema cache");
            if (isSchemaCache) {
                const hint = `إذا استمر الخطأ، فالغالب أن دور anon لا يملك صلاحيات على جدول ${tableName} أو أن RLS تمنع الوصول.`;
                const reloadHint = "انتظر دقيقة ثم حدّث الصفحة، أو نفّذ Reload schema cache من إعدادات Supabase (API).";
                if (a === "save" || a === "update" || a === "delete") {
                    return `تعذر تنفيذ العملية لأن Supabase لم يُحدّث المخطط بعد. ${reloadHint} ${hint}`;
                }
                return `تعذر تحميل بيانات الأبناء لأن Supabase لم يُحدّث المخطط بعد. ${reloadHint} ${hint}`;
            }

            const isMissingTable =
                lowCode === "42p01" ||
                (lowMsg.includes("relation") && lowMsg.includes("does not exist")) ||
                (lowDetails.includes("relation") && lowDetails.includes("does not exist"));
            if (isMissingTable) {
                if (a === "save") return `يلزم إنشاء جدول ${tableName} في Supabase قبل حفظ الأبناء.`;
                return `يلزم إنشاء جدول ${tableName} في Supabase لعرض الأبناء.`;
            }

            const isRls = lowMsg.includes("row-level security") || lowDetails.includes("row-level security") || lowMsg.includes("violates row-level security");
            if (isRls) {
                if (a === "save") return `تعذر حفظ بيانات الابن بسبب صلاحيات الجدول (RLS). تأكد من سياسة INSERT على جدول ${tableName}.`;
                if (a === "update") return `تعذر تعديل بيانات الابن بسبب صلاحيات الجدول (RLS). تأكد من سياسة UPDATE على جدول ${tableName}.`;
                if (a === "delete") return `تعذر حذف بيانات الابن بسبب صلاحيات الجدول (RLS). تأكد من سياسة DELETE على جدول ${tableName}.`;
                return `تعذر تحميل بيانات الأبناء بسبب صلاحيات الجدول (RLS). تأكد من سياسات SELECT/INSERT/UPDATE/DELETE على جدول ${tableName}.`;
            }

            const isPermission = lowMsg.includes("permission denied") || lowDetails.includes("permission denied") || lowCode === "42501";
            if (isPermission) {
                if (a === "save") return `تعذر حفظ بيانات الابن بسبب عدم وجود صلاحية على جدول ${tableName}. افتح admin.html ثم انسخ SQL الخاص بالشجرة ونفّذه في Supabase لتفعيل دوال الحفظ وتحديث الصلاحيات.`;
                if (a === "update") return `تعذر تعديل بيانات الابن بسبب عدم وجود صلاحية على جدول ${tableName}. افتح admin.html ثم انسخ SQL الخاص بالشجرة ونفّذه في Supabase لتفعيل دوال التعديل وتحديث الصلاحيات.`;
                if (a === "delete") return `تعذر حذف بيانات الابن بسبب عدم وجود صلاحية على جدول ${tableName}. افتح admin.html ثم انسخ SQL الخاص بالشجرة ونفّذه في Supabase لتفعيل دوال الحذف وتحديث الصلاحيات.`;
                return `تعذر تحميل بيانات الأبناء بسبب عدم وجود صلاحية على جدول ${tableName}.`;
            }

            const isSchemaMismatch = lowMsg.includes("column") && lowMsg.includes("does not exist");
            if (isSchemaMismatch) {
                const neededCore = wrapLTRText("branch_key + (parent_name أو parent) + (child_name أو name)");
                const optional = wrapLTRText("birth_date_g, birth_date_h, birth_year, city, area, is_deceased, created_at");
                if (a === "save" || a === "update" || a === "delete") {
                    return `تعذر تنفيذ العملية لأن أعمدة جدول ${tableName} غير مطابقة. المطلوب على الأقل: ${neededCore}. الأعمدة الإضافية اختيارية: ${optional}.`;
                }
                return `تعذر تحميل بيانات الأبناء لأن أعمدة جدول ${tableName} غير مطابقة. المطلوب على الأقل: ${neededCore}. الأعمدة الإضافية اختيارية: ${optional}.`;
            }

            if (a === "save") return `تعذر حفظ بيانات الابن: ${msgRaw || "خطأ غير معروف"}`;
            if (a === "update") return `تعذر تعديل بيانات الابن: ${msgRaw || "خطأ غير معروف"}`;
            if (a === "delete") return `تعذر حذف بيانات الابن: ${msgRaw || "خطأ غير معروف"}`;
            return `تعذر تحميل بيانات الأبناء: ${msgRaw || "خطأ غير معروف"}`;
        }

        function classifyTreeChildrenDbError(err) {
            const msgRaw = err && err.message != null ? String(err.message) : "";
            const detailsRaw = err && err.details != null ? String(err.details) : "";
            const lowMsg = msgRaw.trim().toLowerCase();
            const lowDetails = detailsRaw.trim().toLowerCase();

            const isSchemaCache =
                lowMsg.includes("schema cache") || lowMsg.includes("could not find the table") || lowDetails.includes("schema cache");
            if (isSchemaCache) return "schema_cache";

            const isRls = lowMsg.includes("row-level security") || lowDetails.includes("row-level security") || lowMsg.includes("violates row-level security");
            if (isRls) return "rls";

            const isPermission = lowMsg.includes("permission denied") || lowDetails.includes("permission denied");
            if (isPermission) return "permission";

            const isColumnMissing = lowMsg.includes("column") && lowMsg.includes("does not exist");
            const isSchemaCacheMissingColumn = lowMsg.includes("schema cache") && lowMsg.includes("could not find") && lowMsg.includes("column");
            if (isColumnMissing || isSchemaCacheMissingColumn) return "missing_column";

            return "other";
        }

        function groupChildrenRows(rows, branchKey) {
            const key = normalizePersonName(branchKey || "");
            const branchRoot = key ? getBranchRootName(key) : "";
            const byParent = {};
            const idsByBase = new Map();

            const buildChildId = (parentId, baseName) => {
                const p = normalizePersonName(parentId || "");
                const b = normalizePersonName(baseName || "");
                if (!p || !b) return "";
                return p + "/" + b;
            };

            const indexKnownId = (nodeId) => {
                const id = normalizePersonName(nodeId || "");
                if (!id) return;
                const parts = id.split("/").map((p) => normalizePersonName(p)).filter(Boolean);
                const base = parts.length ? parts[parts.length - 1] : id;
                if (!base) return;
                const existing = idsByBase.get(base);
                if (existing) {
                    existing.add(id);
                    return;
                }
                idsByBase.set(base, new Set([id]));
            };

            const addOrMergeChildById = (parentId, child) => {
                const parent = normalizePersonName(parentId || "");
                const name = normalizePersonName(child && child.name ? child.name : "");
                if (!parent || !name) return;
                if (!byParent[parent]) byParent[parent] = [];
                const list = byParent[parent];
                const idx = (Array.isArray(list) ? list : []).findIndex((c) => normalizePersonName(c && c.name ? c.name : "") === name);
                const merged = {
                    name,
                    year: child && child.year ? String(child.year) : "",
                    gdate: child && child.gdate ? String(child.gdate) : "",
                    hdate: child && child.hdate ? String(child.hdate) : "",
                    city: child && child.city ? String(child.city) : "",
                    area: child && child.area ? String(child.area) : "",
                    deceased: !!(child && child.deceased)
                };
                if (idx < 0) {
                    list.push(merged);
                    return;
                }
                const prev = list[idx];
                if (prev) {
                    if (!prev.year && merged.year) prev.year = merged.year;
                    if (!prev.gdate && merged.gdate) prev.gdate = merged.gdate;
                    if (!prev.hdate && merged.hdate) prev.hdate = merged.hdate;
                    if (!prev.city && merged.city) prev.city = merged.city;
                    if (!prev.area && merged.area) prev.area = merged.area;
                    if (!prev.deceased && merged.deceased) prev.deceased = true;
                }
            };

            const addOrMergeChildAndIndex = (parentId, child) => {
                addOrMergeChildById(parentId, child);
                const p = normalizePersonName(parentId || "");
                if (p) indexKnownId(p);
                const n = normalizePersonName(child && child.name ? child.name : "");
                if (n) indexKnownId(n);
            };

            const ensureParentId = (rawParent) => {
                const raw = normalizePersonName(rawParent || "");
                if (!raw) return "";
                if (raw.includes("/")) return raw;
                if (branchRoot && (raw === branchRoot || raw === key)) return branchRoot;
                const candidates = idsByBase.get(raw);
                if (candidates && candidates.size === 1) return Array.from(candidates)[0];
                if (branchRoot) {
                    const parentId = buildChildId(branchRoot, raw);
                    if (parentId) addOrMergeChildAndIndex(branchRoot, { name: parentId, year: "", gdate: "", hdate: "", city: "", area: "" });
                    return parentId;
                }
                return raw;
            };

            const stripBranchSuffix = (tokens) => {
                const t = Array.isArray(tokens) ? tokens.map((x) => normalizePersonName(x)).filter(Boolean) : [];
                if (!key) return t;
                if (t.length >= 3) {
                    const a = normalizePersonName(t[t.length - 3] || "");
                    const b = normalizePersonName(t[t.length - 2] || "");
                    const c = normalizePersonName(t[t.length - 1] || "");
                    if (a === key && b === "مطلق" && c === "زيدان") return t.slice(0, -3);
                }
                if (t.length >= 2) {
                    const b = normalizePersonName(t[t.length - 2] || "");
                    const c = normalizePersonName(t[t.length - 1] || "");
                    if (b === key && c === "مطلق") return t.slice(0, -2);
                }
                if (t.length >= 1 && normalizePersonName(t[t.length - 1] || "") === key) return t.slice(0, -1);
                return t;
            };

            const normalizeChildId = (rawChildId, parentId) => {
                const c = normalizePersonName(rawChildId || "");
                if (!c || !c.includes("/")) return c;
                const p = normalizePersonName(parentId || "");
                if (!p) return c;
                if (c === p || c.startsWith(p + "/")) return c;
                if (branchRoot && (c === branchRoot || c.startsWith(branchRoot + "/"))) return c;
                const base = p.split("/").map((x) => normalizePersonName(x)).filter(Boolean).slice(-1)[0] || "";
                if (base && c.startsWith(base + "/")) return p + "/" + c.slice((base + "/").length);
                return c;
            };

            const addChain = (anchorParentId, basesOldestToYoungest, leafMeta) => {
                const anchor = normalizePersonName(anchorParentId || "");
                const chain = Array.isArray(basesOldestToYoungest)
                    ? basesOldestToYoungest.map((x) => normalizePersonName(x)).filter(Boolean)
                    : [];
                if (!anchor || !chain.length) return;
                let current = anchor;
                indexKnownId(current);
                for (let i = 0; i < chain.length; i++) {
                    const base = chain[i];
                    const childId = buildChildId(current, base);
                    if (!childId) return;
                    const isLeaf = i === chain.length - 1;
                    addOrMergeChildAndIndex(
                        current,
                        isLeaf
                            ? { ...(leafMeta || {}), name: childId }
                            : { name: childId, year: "", gdate: "", hdate: "", city: "", area: "", created_at: "" }
                    );
                    current = childId;
                }
            };

            (Array.isArray(rows) ? rows : []).forEach((r) => {
                let parentRaw = normalizeParentName(r.parent_name || r.parent || "", key);
                let childRaw = normalizePersonName(r.child_name || r.name || "");
                if (!parentRaw || !childRaw) return;

                const meta = {
                    name: "",
                    year: r.birth_year == null ? "" : String(r.birth_year),
                    gdate: normalizePersonName(r.birth_date_g || r.birth_date || ""),
                    hdate: normalizePersonName(r.birth_date_h || ""),
                    city: normalizePersonName(r.city || ""),
                    area: normalizePersonName(r.area || ""),
                    deceased:
                        parseTruthyValue(r.is_deceased) ||
                        parseTruthyValue(r.deceased) ||
                        parseTruthyValue(r.is_dead) ||
                        parseTruthyValue(r.dead) ||
                        parseTruthyValue(r.isDead)
                };

                const parentId = ensureParentId(parentRaw);
                if (!parentId) return;

                if (childRaw.includes("/")) {
                    addOrMergeChildAndIndex(parentId, { ...meta, name: normalizeChildId(childRaw, parentId) });
                    return;
                }

                const rawTokens = tokenizeLineageInput(normalizePersonBaseName(childRaw));
                const tokens = stripBranchSuffix(rawTokens);
                if (!tokens.length) return;

                const hadBranchSuffix = tokens.length !== rawTokens.length;
                if (hadBranchSuffix && branchRoot) {
                    const chainOldest = tokens.slice().reverse();
                    addChain(branchRoot, chainOldest, meta);
                    return;
                }

                if (tokens.length > 1) {
                    const chainOldest = tokens.slice().reverse();
                    const parentBase = normalizePersonBaseName(parentId);
                    if (chainOldest.length && parentBase && chainOldest[0] === parentBase) chainOldest.shift();
                    addChain(parentId, chainOldest, meta);
                    return;
                }

                addChain(parentId, [tokens[0]], meta);
            });

            const forcedMap = {};
            const forcedBases = Object.keys(FORCED_RAHMA_BY_BASE);
            if (forcedBases.length) {
                const pickBestId = (ids) => {
                    const list = (Array.isArray(ids) ? ids : []).map((x) => normalizePersonName(x)).filter(Boolean);
                    if (!list.length) return "";
                    const root = normalizePersonName(branchRoot);
                    list.sort((a, b) => {
                        const aInRoot = root ? (a === root || a.startsWith(root + "/")) : false;
                        const bInRoot = root ? (b === root || b.startsWith(root + "/")) : false;
                        if (aInRoot !== bInRoot) return aInRoot ? -1 : 1;
                        const aDepth = a.split("/").filter(Boolean).length;
                        const bDepth = b.split("/").filter(Boolean).length;
                        if (aDepth !== bDepth) return aDepth - bDepth;
                        if (a.length !== b.length) return a.length - b.length;
                        return a.localeCompare(b, "ar");
                    });
                    return list[0] || "";
                };

                forcedBases.forEach((base) => {
                    const b = normalizePersonName(base);
                    if (!b) return;
                    const set = idsByBase.get(b);
                    if (!set || !set.size) return;
                    const picked = pickBestId(Array.from(set));
                    if (picked) forcedMap[b] = picked;
                });
            }
            if (key) state.forcedRahmaByBranch[key] = forcedMap;

            return byParent;
        }

        async function loadChildrenQuery(sb, branchKey, fields) {
            const raw = String(fields || "*");
            const cleaned = raw
                .split(",")
                .map((x) => String(x || "").trim())
                .filter(Boolean)
                .filter((x) => x !== "created_at")
                .join(",");
            return await sb
                .from(FAMILY_TREE_CHILDREN_TABLE)
                .select(cleaned || "*")
                .eq("branch_key", branchKey)
                .limit(2000);
        }

        async function loadChildrenForBranch(branchKey, opts) {
            const options = opts || {};
            const sb = getSupabaseClient();
            if (!sb) return { ok: false, reason: "not_configured" };
            const key = String(branchKey || "").trim();
            if (!key) return { ok: false, reason: "missing_branch" };
            const fieldAttempts = [
                "parent_name,parent,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent,name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent,child_name,birth_date_g,birth_date_h,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,parent,child_name,name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent,name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent,child_name,birth_year,city,area,is_deceased,deceased,created_at",
                "parent_name,parent,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent_name,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent_name,child_name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent_name,name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent,name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent,child_name,birth_date_g,birth_date_h,birth_year,city,area,deceased,created_at",
                "parent_name,parent,child_name,name,birth_year,city,area,deceased,created_at",
                "parent_name,child_name,name,birth_year,city,area,deceased,created_at",
                "parent_name,child_name,birth_year,city,area,deceased,created_at",
                "parent_name,name,birth_year,city,area,deceased,created_at",
                "parent,name,birth_year,city,area,deceased,created_at",
                "parent,child_name,birth_year,city,area,deceased,created_at",
                "parent_name,parent,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent_name,child_name,name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent_name,child_name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent_name,name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent,name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent,child_name,birth_date_g,birth_date_h,birth_year,city,area,created_at",
                "parent_name,parent,child_name,name,birth_year,city,area,created_at",
                "parent_name,child_name,name,birth_year,city,area,created_at",
                "parent_name,child_name,birth_year,city,area,created_at",
                "parent_name,name,birth_year,city,area,created_at",
                "parent,name,birth_year,city,area,created_at",
                "parent,child_name,birth_year,city,area,created_at",
                "parent_name,parent,child_name,name,created_at",
                "parent_name,child_name,name,created_at",
                "parent_name,child_name,created_at",
                "parent_name,name,created_at",
                "parent,child_name,created_at",
                "parent,name,created_at",
                "parent_name,parent,child_name,name",
                "parent_name,child_name,name",
                "parent_name,child_name",
                "parent_name,name",
                "parent,child_name",
                "parent,name",
                "parent_name,parent,child_name,name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent_name,child_name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent_name,name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent,name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent,child_name,gdate,hdate,year,city,area,is_deceased,deceased,created_at",
                "parent_name,parent,child_name,name,year,city,area,created_at",
                "parent_name,child_name,name,year,city,area,created_at",
                "parent_name,child_name,year,city,area,created_at",
                "parent_name,name,year,city,area,created_at",
                "parent,name,year,city,area,created_at",
                "parent,child_name,year,city,area,created_at"
            ];
            let lastError = null;
            let deceasedFallbackHint = "";
            for (let i = 0; i < fieldAttempts.length; i++) {
                const usedFields = fieldAttempts[i];
                const res = await loadChildrenQuery(sb, key, usedFields);
                if (!res.error) {
                    const map = groupChildrenRows(res.data, key);
                    const supportsDeceased = usedFields.includes("is_deceased") || usedFields.includes("deceased");
                    if (options.applyToState === true) state.children = map;
                    return { ok: true, map, capabilities: { deceased: supportsDeceased, deceased_hint: supportsDeceased ? "" : deceasedFallbackHint } };
                }
                if (!deceasedFallbackHint && (usedFields.includes("is_deceased") || usedFields.includes("deceased"))) {
                    deceasedFallbackHint = classifyTreeChildrenDbError(res.error);
                }
                const msg = String(res.error.message || "").toLowerCase();
                const isColumnMissing = msg.includes("column") && msg.includes("does not exist");
                const isSchemaCacheMissingColumn = msg.includes("schema cache") && msg.includes("could not find") && msg.includes("column");
                const canRetry = isColumnMissing || isSchemaCacheMissingColumn;
                if (!canRetry) return { ok: false, reason: "error", error: res.error };
                lastError = res.error;
            }
            return { ok: false, reason: "error", error: lastError };
        }

        async function insertTreeChildRow(sb, row) {
            const attempts = [];
            const deceasedValue = row && (row.is_deceased != null ? row.is_deceased : row.deceased);
            const full = {
                branch_key: row.branch_key,
                parent_name: row.parent_name,
                child_name: row.child_name,
                birth_date_g: row.birth_date_g,
                birth_date_h: row.birth_date_h,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const fullDeceased = {
                ...full,
                is_deceased: deceasedValue
            };
            const fullDeceasedAlt = {
                ...full,
                deceased: deceasedValue
            };
            const noDates = {
                branch_key: row.branch_key,
                parent_name: row.parent_name,
                child_name: row.child_name,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const noDatesDeceased = {
                ...noDates,
                is_deceased: deceasedValue
            };
            const noDatesDeceasedAlt = {
                ...noDates,
                deceased: deceasedValue
            };
            const fullName = {
                branch_key: row.branch_key,
                parent_name: row.parent_name,
                name: row.child_name,
                birth_date_g: row.birth_date_g,
                birth_date_h: row.birth_date_h,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const fullNameDeceased = {
                ...fullName,
                is_deceased: deceasedValue
            };
            const fullNameDeceasedAlt = {
                ...fullName,
                deceased: deceasedValue
            };
            const noDatesName = {
                branch_key: row.branch_key,
                parent_name: row.parent_name,
                name: row.child_name,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const noDatesNameDeceased = {
                ...noDatesName,
                is_deceased: deceasedValue
            };
            const noDatesNameDeceasedAlt = {
                ...noDatesName,
                deceased: deceasedValue
            };
            const fullParent = {
                branch_key: row.branch_key,
                parent: row.parent_name,
                name: row.child_name,
                birth_date_g: row.birth_date_g,
                birth_date_h: row.birth_date_h,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const fullParentDeceased = {
                ...fullParent,
                is_deceased: deceasedValue
            };
            const fullParentDeceasedAlt = {
                ...fullParent,
                deceased: deceasedValue
            };
            const noDatesParent = {
                branch_key: row.branch_key,
                parent: row.parent_name,
                name: row.child_name,
                birth_year: row.birth_year,
                city: row.city,
                area: row.area
            };
            const noDatesParentDeceased = {
                ...noDatesParent,
                is_deceased: deceasedValue
            };
            const noDatesParentDeceasedAlt = {
                ...noDatesParent,
                deceased: deceasedValue
            };
            attempts.push({ row: fullDeceased });
            attempts.push({ row: fullDeceasedAlt });
            attempts.push({ row: full });
            attempts.push({ row: noDatesDeceased });
            attempts.push({ row: noDatesDeceasedAlt });
            attempts.push({ row: noDates });
            attempts.push({ row: fullNameDeceased });
            attempts.push({ row: fullNameDeceasedAlt });
            attempts.push({ row: fullName });
            attempts.push({ row: noDatesNameDeceased });
            attempts.push({ row: noDatesNameDeceasedAlt });
            attempts.push({ row: noDatesName });
            attempts.push({ row: fullParentDeceased });
            attempts.push({ row: fullParentDeceasedAlt });
            attempts.push({ row: fullParent });
            attempts.push({ row: noDatesParentDeceased });
            attempts.push({ row: noDatesParentDeceasedAlt });
            attempts.push({ row: noDatesParent });
            for (let i = 0; i < attempts.length; i++) {
                const { error } = await sb.from(FAMILY_TREE_CHILDREN_TABLE).insert(attempts[i].row);
                if (!error) {
                    const used = attempts[i].row || {};
                    const degraded = deceasedValue != null && used.is_deceased == null && used.deceased == null;
                    return { ok: true, degraded };
                }
                const msg = String(error.message || "").toLowerCase();
                const isColumnMissing = msg.includes("column") && msg.includes("does not exist");
                const isSchemaCacheMissingColumn = msg.includes("schema cache") && msg.includes("could not find") && msg.includes("column");
                const isNotNullName = msg.includes('column "name"') && msg.includes("null value");
                const isNotNullChildName = msg.includes('column "child_name"') && msg.includes("null value");
                if (!isColumnMissing && !isSchemaCacheMissingColumn && !isNotNullName && !isNotNullChildName) return { ok: false, error };
                if (i === attempts.length - 1) return { ok: false, error };
            }
            return { ok: false, error: { message: "unknown insert error" } };
        }

        async function updateTreeChildRow(sb, branchKey, parentId, childId, patch) {
            const attempts = [];
            const key = normalizePersonName(branchKey || "");
            const parent = normalizePersonName(parentId || "");
            const id = normalizePersonName(childId || "");
            if (!key || !parent || !id) return { ok: false, error: { message: "missing key" } };
            const p = patch || {};
            const updateBase = {
                birth_date_g: p.birth_date_g,
                birth_date_h: p.birth_date_h,
                birth_year: p.birth_year,
                city: p.city,
                area: p.area
            };
            const deceasedValue = p && (p.is_deceased != null ? p.is_deceased : p.deceased);
            const updateWithDeceased = { ...updateBase, is_deceased: deceasedValue };
            const updateWithDeceasedAlt = { ...updateBase, deceased: deceasedValue };
            const parentCols = ["parent_name", "parent"];
            const childCols = ["child_name", "name"];
            const updateRows = [updateWithDeceased, updateWithDeceasedAlt, updateBase];
            parentCols.forEach((parentCol) => {
                childCols.forEach((childCol) => {
                    updateRows.forEach((updateRow) => {
                        attempts.push({ parentCol, childCol, updateRow });
                    });
                });
            });

            for (let i = 0; i < attempts.length; i++) {
                const a = attempts[i];
                const { data, error } = await sb
                    .from(FAMILY_TREE_CHILDREN_TABLE)
                    .update(a.updateRow)
                    .eq("branch_key", key)
                    .eq(a.parentCol, parent)
                    .eq(a.childCol, id)
                    .select(a.childCol);
                if (!error && Array.isArray(data) && data.length) {
                    const used = a.updateRow || {};
                    const degraded = deceasedValue != null && used.is_deceased == null && used.deceased == null;
                    return { ok: true, degraded };
                }
                if (!error && Array.isArray(data) && data.length === 0) {
                    if (i === attempts.length - 1) return { ok: false, error: { message: "row not found" } };
                    continue;
                }
                const msg = String(error.message || "").toLowerCase();
                const isColumnMissing = msg.includes("column") && msg.includes("does not exist");
                const isSchemaCacheMissingColumn = msg.includes("schema cache") && msg.includes("could not find") && msg.includes("column");
                const canRetry = isColumnMissing || isSchemaCacheMissingColumn;
                if (!canRetry) return { ok: false, error };
                if (i === attempts.length - 1) return { ok: false, error };
            }
            return { ok: false, error: { message: "unknown update error" } };
        }

        async function deleteTreeChildRow(sb, branchKey, parentId, childId) {
            const attempts = [];
            const key = normalizePersonName(branchKey || "");
            const parent = normalizePersonName(parentId || "");
            const id = normalizePersonName(childId || "");
            if (!key || !parent || !id) return { ok: false, error: { message: "missing key" } };
            const parentCols = ["parent_name", "parent"];
            const childCols = ["child_name", "name"];
            parentCols.forEach((parentCol) => {
                childCols.forEach((childCol) => {
                    attempts.push({ parentCol, childCol });
                });
            });

            for (let i = 0; i < attempts.length; i++) {
                const a = attempts[i];
                const { data, error } = await sb
                    .from(FAMILY_TREE_CHILDREN_TABLE)
                    .delete()
                    .eq("branch_key", key)
                    .eq(a.parentCol, parent)
                    .eq(a.childCol, id)
                    .select(a.childCol);
                if (!error && Array.isArray(data) && data.length) return { ok: true };
                if (!error && Array.isArray(data) && data.length === 0) {
                    if (i === attempts.length - 1) return { ok: false, error: { message: "row not found" } };
                    continue;
                }

                const msg = String(error.message || "").toLowerCase();
                const isColumnMissing = msg.includes("column") && msg.includes("does not exist");
                const isSchemaCacheMissingColumn = msg.includes("schema cache") && msg.includes("could not find") && msg.includes("column");
                const canRetry = isColumnMissing || isSchemaCacheMissingColumn;
                if (!canRetry) return { ok: false, error };
                if (i === attempts.length - 1) return { ok: false, error };
            }
            return { ok: false, error: { message: "unknown delete error" } };
        }

        function isRpcMissingError(err) {
            const msg = String(err && err.message ? err.message : "").toLowerCase();
            const code = String(err && err.code ? err.code : "").toLowerCase();
            if (code === "pgrst202") return true;
            if (msg.includes("could not find the function")) return true;
            if (msg.includes("function") && msg.includes("does not exist")) return true;
            if (msg.includes("schema cache") && msg.includes("function")) return true;
            return false;
        }

        function isCaseTypesTextAndDateMismatchError(err) {
            const msg = String(err && err.message ? err.message : "").toLowerCase();
            const details = String(err && err.details ? err.details : "").toLowerCase();
            const low = (msg + " " + details).trim();
            return low.includes("case types") && low.includes("text") && low.includes("date") && low.includes("cannot be matched");
        }

        function confirmTypedText(expectedRaw, opts) {
            const options = opts || {};
            const expected = normalizePersonName(expectedRaw || "");
            if (!expected) return Promise.resolve(false);
            const title = String(options.title || "تأكيد").trim() || "تأكيد";
            const body = String(options.body || "").trim();
            const confirmLabel = String(options.confirmLabel || "تأكيد").trim() || "تأكيد";
            const cancelLabel = String(options.cancelLabel || "إلغاء").trim() || "إلغاء";
            return new Promise((resolve) => {
                const overlay = document.createElement("div");
                overlay.style.position = "fixed";
                overlay.style.inset = "0";
                overlay.style.background = "rgba(0, 0, 0, 0.55)";
                overlay.style.display = "flex";
                overlay.style.alignItems = "center";
                overlay.style.justifyContent = "center";
                overlay.style.zIndex = "99999";
                overlay.dir = "rtl";

                const card = document.createElement("div");
                card.style.width = "min(92vw, 520px)";
                card.style.background = "#fff";
                card.style.borderRadius = "14px";
                card.style.padding = "14px 14px 12px";
                card.style.boxShadow = "0 14px 40px rgba(0,0,0,0.25)";
                card.style.border = "1px solid rgba(0,0,0,0.08)";

                const h = document.createElement("div");
                h.textContent = title;
                h.style.fontWeight = "700";
                h.style.fontSize = "16px";
                h.style.marginBottom = "8px";

                const p = document.createElement("div");
                p.style.marginBottom = "10px";
                p.style.color = "#374151";
                p.style.fontSize = "13px";
                p.textContent = body || "اكتب النص التالي لتأكيد العملية:";

                const expectedBox = document.createElement("div");
                expectedBox.style.background = "#f3f4f6";
                expectedBox.style.border = "1px solid #e5e7eb";
                expectedBox.style.borderRadius = "10px";
                expectedBox.style.padding = "10px 12px";
                expectedBox.style.fontWeight = "700";
                expectedBox.style.marginBottom = "10px";
                expectedBox.style.userSelect = "text";
                expectedBox.textContent = expected;

                const input = document.createElement("input");
                input.type = "text";
                input.autocomplete = "off";
                input.inputMode = "text";
                input.style.width = "100%";
                input.style.padding = "10px 12px";
                input.style.borderRadius = "10px";
                input.style.border = "1px solid #d1d5db";
                input.style.outline = "none";
                input.style.fontSize = "14px";
                input.placeholder = "اكتب هنا...";

                const actions = document.createElement("div");
                actions.style.display = "flex";
                actions.style.gap = "8px";
                actions.style.marginTop = "12px";
                actions.style.justifyContent = "flex-start";

                const cancelBtn = document.createElement("button");
                cancelBtn.type = "button";
                cancelBtn.className = "btn btn-secondary btn-small";
                cancelBtn.textContent = cancelLabel;

                const okBtn = document.createElement("button");
                okBtn.type = "button";
                okBtn.className = "btn btn-primary btn-small";
                okBtn.textContent = confirmLabel;
                okBtn.disabled = true;

                const cleanup = (v) => {
                    try {
                        document.removeEventListener("keydown", onKeyDown, true);
                    } catch (e) {}
                    try {
                        overlay.remove();
                    } catch (e) {}
                    resolve(!!v);
                };

                const isMatch = () => normalizePersonName(input.value || "") === expected;
                const refresh = () => {
                    okBtn.disabled = !isMatch();
                };

                const onKeyDown = (e) => {
                    if (!e) return;
                    if (e.key === "Escape") {
                        e.preventDefault();
                        cleanup(false);
                        return;
                    }
                    if (e.key === "Enter") {
                        if (isMatch()) {
                            e.preventDefault();
                            cleanup(true);
                        }
                    }
                };

                overlay.addEventListener("click", (e) => {
                    if (e && e.target === overlay) cleanup(false);
                });
                cancelBtn.addEventListener("click", () => cleanup(false));
                okBtn.addEventListener("click", () => cleanup(true));
                input.addEventListener("input", refresh);
                document.addEventListener("keydown", onKeyDown, true);

                card.appendChild(h);
                card.appendChild(p);
                card.appendChild(expectedBox);
                card.appendChild(input);
                actions.appendChild(cancelBtn);
                actions.appendChild(okBtn);
                card.appendChild(actions);
                overlay.appendChild(card);
                document.body.appendChild(overlay);
                setTimeout(() => {
                    try {
                        input.focus();
                        input.select();
                    } catch (e) {}
                }, 0);
            });
        }

        function isOnConflictConstraintError(err) {
            const msg = String(err && err.message ? err.message : "").toLowerCase();
            return msg.includes("no unique or exclusion constraint matching the on conflict specification");
        }

        async function getDelegateRpcAuth() {
            const session = loadDelegateSession();
            if (!session) return { ok: false, reason: "no_session" };
            const secretHash = await sha256Hex(session.secret);
            if (!secretHash) return { ok: false, reason: "hash_failed" };
            return { ok: true, branch: session.branch, phone: session.phone, email: session.email, secretHash };
        }

        async function rpcInsertTreeChildRow(sb, row) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const r = row || {};
            const key = normalizePersonName(r.branch_key || "");
            const parent = normalizePersonName(r.parent_name || r.parent || "");
            const id = normalizePersonName(r.child_name || r.name || "");
            if (!key || !parent || !id) return { ok: false, error: { message: "missing key" } };
            const { data, error } = await sb.rpc("tree_children_insert_v1", {
                p_branch_key: key,
                p_parent_name: parent,
                p_child_name: id,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash,
                p_row: r
            });
            if (error) {
                if (isOnConflictConstraintError(error)) {
                    return { ok: false, error };
                }
                return { ok: false, error };
            }
            return data === true ? { ok: true } : { ok: false, error: { message: "not allowed" } };
        }

        async function rpcUpdateTreeChildRow(sb, branchKey, parentId, childId, patch) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const key = normalizePersonName(branchKey || "");
            const parent = normalizePersonName(parentId || "");
            const id = normalizePersonName(childId || "");
            if (!key || !parent || !id) return { ok: false, error: { message: "missing key" } };
            const { data, error } = await sb.rpc("tree_children_update_v1", {
                p_branch_key: key,
                p_parent_name: parent,
                p_child_name: id,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash,
                p_patch: patch || {}
            });
            if (error) return { ok: false, error };
            return data === true ? { ok: true } : { ok: false, error: { message: "not allowed" } };
        }

        async function rpcDeleteTreeChildRow(sb, branchKey, parentId, childId) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const key = normalizePersonName(branchKey || "");
            const parent = normalizePersonName(parentId || "");
            const id = normalizePersonName(childId || "");
            if (!key || !parent || !id) return { ok: false, error: { message: "missing key" } };
            const { data, error } = await sb.rpc("tree_children_delete_v1", {
                p_branch_key: key,
                p_parent_name: parent,
                p_child_name: id,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash
            });
            if (error) return { ok: false, error };
            return data === true ? { ok: true } : { ok: false, error: { message: "not allowed" } };
        }

        async function rpcInsertFamilyEventRow(sb, row) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const key = normalizePersonName(state.branch || auth.branch || "");
            if (!key) return { ok: false, error: { message: "missing branch" } };
            const { data, error } = await sb.rpc("family_events_insert_v1", {
                p_branch_key: key,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash,
                p_row: row || {}
            });
            if (error) return { ok: false, error };
            if (data === true) return { ok: true };
            try {
                const info = await sb.rpc("check_events_delegate_access", {
                    p_branch_key: key,
                    p_phone: auth.phone,
                    p_email: auth.email,
                    p_secret_hash: auth.secretHash
                });
                if (!info.error && info.data && typeof info.data === "object") {
                    return {
                        ok: false,
                        error: {
                            message: "not allowed",
                            detail: "events_access",
                            status: info.data.status || null,
                            requestId: info.data.request_id || null
                        }
                    };
                }
            } catch (e) {}
            return { ok: false, error: { message: "not allowed" } };
        }

        async function rpcUpdateFamilyEventRow(sb, pk, patch) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const key = normalizePersonName(state.branch || auth.branch || "");
            if (!key) return { ok: false, error: { message: "missing branch" } };
            if (!pk || !pk.col || pk.value == null) return { ok: false, error: { message: "missing pk" } };
            const { data, error } = await sb.rpc("family_events_update_v1", {
                p_branch_key: key,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash,
                p_pk_col: String(pk.col),
                p_pk_value: String(pk.value),
                p_patch: patch || {}
            });
            if (error) return { ok: false, error };
            if (data === true) return { ok: true };
            try {
                const info = await sb.rpc("check_events_delegate_access", {
                    p_branch_key: key,
                    p_phone: auth.phone,
                    p_email: auth.email,
                    p_secret_hash: auth.secretHash
                });
                if (!info.error && info.data && typeof info.data === "object") {
                    return {
                        ok: false,
                        error: {
                            message: "not allowed",
                            detail: "events_access",
                            status: info.data.status || null,
                            requestId: info.data.request_id || null
                        }
                    };
                }
            } catch (e) {}
            return { ok: false, error: { message: "not allowed" } };
        }

        async function rpcDeleteFamilyEventRow(sb, pk) {
            const auth = await getDelegateRpcAuth();
            if (!auth.ok) return { ok: false, error: { message: auth.reason } };
            const key = normalizePersonName(state.branch || auth.branch || "");
            if (!key) return { ok: false, error: { message: "missing branch" } };
            if (!pk || !pk.col || pk.value == null) return { ok: false, error: { message: "missing pk" } };
            const { data, error } = await sb.rpc("family_events_delete_v1", {
                p_branch_key: key,
                p_phone: auth.phone,
                p_email: auth.email,
                p_secret_hash: auth.secretHash,
                p_pk_col: String(pk.col),
                p_pk_value: String(pk.value)
            });
            if (error) return { ok: false, error };
            if (data === true) return { ok: true };
            try {
                const info = await sb.rpc("check_events_delegate_access", {
                    p_branch_key: key,
                    p_phone: auth.phone,
                    p_email: auth.email,
                    p_secret_hash: auth.secretHash
                });
                if (!info.error && info.data && typeof info.data === "object") {
                    return {
                        ok: false,
                        error: {
                            message: "not allowed",
                            detail: "events_access",
                            status: info.data.status || null,
                            requestId: info.data.request_id || null
                        }
                    };
                }
            } catch (e) {}
            return { ok: false, error: { message: "not allowed" } };
        }

        function renderParentsForBranch(branchKey) {
            parentSelect.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "اختر الأب لإضافة أبنائه";
            parentSelect.appendChild(option);

            const branchRoot = getBranchRootName(branchKey);
            const staticParentIds = (parentsByBranch[branchKey] || [])
                .map(normalizePersonName)
                .filter(Boolean)
                .map((base) => (branchRoot ? (branchRoot + "/" + base) : base));
            const dynamicParents = Object.keys(state.children || {});
            const dynamicChildren = [];
            Object.values(state.children || {}).forEach((list) => {
                (Array.isArray(list) ? list : []).forEach((c) => {
                    const n = normalizePersonName(c && c.name ? c.name : "");
                    if (n) dynamicChildren.push(n);
                });
            });
            const ids = [branchRoot, ...staticParentIds, ...dynamicParents, ...dynamicChildren].map(normalizePersonName).filter(Boolean);
            const baseCounts = new Map();
            ids.forEach((id) => {
                const base = getDisplayNameForNodeId(id, branchRoot);
                if (!base) return;
                baseCounts.set(base, (baseCounts.get(base) || 0) + 1);
            });
            const seen = new Set();
            ids.forEach((id) => {
                const n = normalizePersonName(id || "");
                if (!n || seen.has(n)) return;
                seen.add(n);
                const base = getDisplayNameForNodeId(n, branchRoot);
                let label = base;
                if (base && (baseCounts.get(base) || 0) > 1) {
                    const parts = n.split("/").map((p) => normalizePersonName(p)).filter(Boolean);
                    parts.pop();
                    const parentBase = parts.length ? parts[parts.length - 1] : "";
                    if (parentBase) label = base + " — " + parentBase;
                }
                const opt = document.createElement("option");
                opt.value = n;
                opt.textContent = label || n;
                parentSelect.appendChild(opt);
            });
        }

        function ensureParentOption(name) {
            const n = normalizePersonName(name || "");
            if (!n || !parentSelect) return;
            const options = Array.from(parentSelect.options || []);
            if (options.some((o) => normalizePersonName(o.value || "") === n)) return;
            const opt = document.createElement("option");
            opt.value = n;
            opt.textContent = getDisplayNameForNodeId(n, state.branch ? getBranchRootName(state.branch) : "");
            parentSelect.appendChild(opt);
        }

        function selectParentForAdding(name) {
            const n = normalizePersonName(name || "");
            if (!n) return;
            ensureParentOption(n);
            parentSelect.value = n;
            renderChildrenForParent(n);
            if (childName && typeof childName.focus === "function") childName.focus();
        }

        let editingChildRef = null;

        function closeEditChild() {
            editingChildRef = null;
            hideEditChildAlert();
            if (editChildCard) editChildCard.style.display = "none";
            if (editChildName) editChildName.textContent = "";
            if (editChildHijri) editChildHijri.value = "";
            if (editChildGreg) editChildGreg.value = "";
            if (editChildCity) editChildCity.value = "";
            if (editChildArea) editChildArea.value = "";
            if (editChildDeceased) editChildDeceased.checked = false;
        }

        function openEditChild(parentId, child) {
            const pid = normalizePersonName(parentId || "");
            const cid = normalizePersonName(child && child.name ? child.name : "");
            if (!state.branch || !pid || !cid) return;
            editingChildRef = { parentId: pid, childId: cid };
            hideEditChildAlert();
            if (editChildCard) editChildCard.style.display = "block";
            if (editChildName) {
                const display = getDisplayNameForNodeId(cid, state.branch ? getBranchRootName(state.branch) : "");
                const forcedSuffix = getForcedRahmaSuffix(cid, state.branch);
                const suffix = forcedSuffix ? forcedSuffix : child && child.deceased ? " (رحمه الله)" : "";
                editChildName.textContent = "الاسم: " + (display || cid) + suffix;
            }
            if (editChildHijri) editChildHijri.value = normalizePersonName(child && child.hdate ? child.hdate : "");
            if (editChildGreg) editChildGreg.value = normalizePersonName(child && child.gdate ? child.gdate : "");
            if (editChildCity) editChildCity.value = normalizePersonName(child && child.city ? child.city : "");
            if (editChildArea) editChildArea.value = normalizePersonName(child && child.area ? child.area : "");
            if (editChildDeceased) editChildDeceased.checked = !!(child && child.deceased);
            applyEditDeceasedUiMode();
            if (editChildCard && typeof editChildCard.scrollIntoView === "function") {
                editChildCard.scrollIntoView({ behavior: "smooth", block: "start" });
            }
        }

        function renderChildrenForParent(parentName) {
            childrenContainer.innerHTML = "";
            const key = normalizePersonName(parentName || "");
            const listRaw = state.children[key] || [];
            const getBirthSortKey = (child) => {
                const g = normalizePersonName(child && child.gdate ? child.gdate : "");
                const gp = parseISODate(g);
                if (gp) return gp.y * 10000 + gp.mo * 100 + gp.d;
                const yRaw = child && child.year != null ? String(child.year) : "";
                const y = parseInt(yRaw, 10);
                if (y && isFinite(y)) return y * 10000;
                return null;
            };
            const shouldSort = Array.isArray(listRaw) && listRaw.some((c) => getBirthSortKey(c) != null);
            const list = shouldSort
                ? listRaw
                      .slice()
                      .sort((a, b) => {
                          const ak = getBirthSortKey(a);
                          const bk = getBirthSortKey(b);
                          if (ak == null && bk == null) {
                              const an = normalizePersonName(a && a.name ? a.name : "");
                              const bn = normalizePersonName(b && b.name ? b.name : "");
                              return an.localeCompare(bn, "ar");
                          }
                          if (ak == null) return 1;
                          if (bk == null) return -1;
                          if (ak !== bk) return ak - bk;
                          const an = normalizePersonName(a && a.name ? a.name : "");
                          const bn = normalizePersonName(b && b.name ? b.name : "");
                          return an.localeCompare(bn, "ar");
                      })
                : listRaw;
            if (!list.length) {
                const empty = document.createElement("div");
                empty.className = "hint";
                empty.textContent = "لا توجد بيانات مسجلة لهذا الأب بعد.";
                childrenContainer.appendChild(empty);
                return;
            }
            list.forEach((child) => {
                const row = document.createElement("div");
                row.className = "child-row";
                const ageText = calculateAge(child);
                const parts = [];
                const childId = normalizePersonName(child.name);
                const display = getDisplayNameForNodeId(childId, state.branch ? getBranchRootName(state.branch) : "");
                const forcedSuffix = getForcedRahmaSuffix(childId, state.branch);
                const suffix = forcedSuffix ? forcedSuffix : child && child.deceased ? " (رحمه الله)" : "";
                parts.push((display || childId) + suffix);
                const isDeceased = !!(child && child.deceased);
                if (!isDeceased) {
                    if (ageText) {
                        parts.push("العمر: " + ageText);
                    }
                    const birthParts = [];
                    const h = normalizePersonName(child && child.hdate ? child.hdate : "");
                    const g = normalizePersonName(child && child.gdate ? child.gdate : "");
                    const y = child && child.year ? String(child.year) : "";
                    let hijriLabel = h ? formatDateISO(h) : "";
                    if (!hijriLabel && g) hijriLabel = formatDateISO(g);
                    if (hijriLabel) birthParts.push(hijriLabel);
                    if (!hijriLabel && y) birthParts.push("سنة: " + y);
                    if (birthParts.length) parts.push("الميلاد: " + birthParts.join(" / "));
                    const city = normalizePersonName(child && child.city ? child.city : "");
                    const area = normalizePersonName(child && child.area ? child.area : "");
                    if (city) parts.push("المدينة: " + city);
                    if (area) parts.push("الحي: " + area);
                    const childCount = Array.isArray(state.children[normalizePersonName(child.name)]) ? state.children[normalizePersonName(child.name)].length : 0;
                    parts.push("الأبناء: " + String(childCount));
                }
                const header = document.createElement("div");
                header.style.display = "flex";
                header.style.alignItems = "center";
                header.style.justifyContent = "space-between";
                header.style.gap = "8px";
                const main = document.createElement("div");
                main.textContent = parts.join(" – ");
                const actions = document.createElement("div");
                actions.style.display = "flex";
                actions.style.gap = "8px";
                actions.style.flexWrap = "wrap";
                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "btn btn-secondary btn-small";
                btn.textContent = "إضافة أبناء";
                btn.addEventListener("click", () => {
                    selectParentForAdding(normalizePersonName(child.name));
                });
                const editBtn = document.createElement("button");
                editBtn.type = "button";
                editBtn.className = "btn btn-secondary btn-small";
                editBtn.textContent = "تعديل";
                editBtn.addEventListener("click", () => {
                    openEditChild(key, child);
                });
                const delBtn = document.createElement("button");
                delBtn.type = "button";
                delBtn.className = "btn btn-secondary btn-small";
                delBtn.textContent = "حذف";
                delBtn.addEventListener("click", async () => {
                    if (!state.branch) {
                        setChildAlert("error", "يلزم تسجيل دخول المندوب أولاً.");
                        return;
                    }
                    const childIdForDelete = normalizePersonName(child && child.name ? child.name : "");
                    const display = getDisplayNameForNodeId(childIdForDelete, state.branch ? getBranchRootName(state.branch) : "");
                    const nameToConfirm = normalizePersonName(display || normalizePersonBaseName(childIdForDelete) || childIdForDelete);
                    const ok = await confirmTypedText(nameToConfirm, {
                        title: "تأكيد حذف الاسم",
                        body: "لتأكيد الحذف اكتب الاسم التالي بالضبط:",
                        confirmLabel: "تأكيد الحذف",
                        cancelLabel: "إلغاء"
                    });
                    if (!ok) return;
                    const sb = getSupabaseClient();
                    if (!sb) {
                        setChildAlert("error", "تعذر الحذف لأن الربط غير مُعد.");
                        return;
                    }
                    closeEditChild();
                    const res = await rpcDeleteTreeChildRow(sb, state.branch, key, childIdForDelete);
                    if (!res.ok) {
                        const err = res.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            setChildAlert(
                                "error",
                                "لا يمكن الحذف الآن لأن دوال الشجرة غير مفعلة في Supabase (tree_children_insert_v1 / tree_children_update_v1 / tree_children_delete_v1)."
                            );
                            return;
                        }
                        setChildAlert("error", formatTreeChildrenDbError(err, "delete"));
                        return;
                    }
                    try {
                        const list = state.children[key];
                        if (Array.isArray(list) && list.length) {
                            const next = list.filter((c) => normalizePersonName(c && c.name ? c.name : "") !== childIdForDelete);
                            state.children[key] = next;
                        }
                    } catch (e) {}
                    const reloadRes = await loadChildrenForBranch(state.branch, { applyToState: true });
                    if (!reloadRes.ok) {
                        renderParentsForBranch(state.branch);
                        renderChildrenForParent(key);
                        setChildAlert("success", "تم حذف الاسم. تعذر تحديث البيانات من قاعدة البيانات الآن، لكن تم تحديث العرض محلياً.");
                        return;
                    }
                    renderParentsForBranch(state.branch);
                    ensureParentOption(key);
                    parentSelect.value = key;
                    renderChildrenForParent(key);
                    setChildAlert("success", "تم حذف الاسم.");
                });
                header.appendChild(main);
                actions.appendChild(editBtn);
                actions.appendChild(delBtn);
                actions.appendChild(btn);
                header.appendChild(actions);
                row.appendChild(header);
                childrenContainer.appendChild(row);
            });
        }

        function normalizePersonBaseName(v) {
            const n = normalizePersonName(v || "");
            if (!n) return "";
            const m = n.match(/^(.*)\s*\((?:ابن|مواليد)\s+[^)]+\)\s*$/);
            const core = m && m[1] ? normalizePersonName(m[1]) : n;
            const parts = core.split("/").map((p) => normalizePersonName(p)).filter(Boolean);
            return parts.length ? parts[parts.length - 1] : core;
        }

        function tokenizeLineageInput(v) {
            const s = normalizePersonName(v || "");
            if (!s) return [];
            return s
                .split(/\s+/g)
                .map((w) => normalizePersonName(w))
                .filter(Boolean)
                .filter((w) => !["بن", "ابن", "بنت"].includes(w));
        }

        function getDisplayNameForNodeId(nodeId, branchRoot) {
            const id = normalizePersonName(nodeId || "");
            if (!id) return "";
            if (branchRoot && id === branchRoot) return id;
            const leaf = id.includes("/")
                ? (id.split("/").map((p) => normalizePersonName(p)).filter(Boolean).slice(-1)[0] || id)
                : id;
            const tokens = tokenizeLineageInput(normalizePersonBaseName(leaf));
            return tokens.length ? tokens[0] : leaf;
        }

        function getLeafBaseNameFromNodeId(nodeId) {
            const id = normalizePersonName(nodeId || "");
            if (!id) return "";
            const leaf = id.includes("/") ? (id.split("/").map((p) => normalizePersonName(p)).filter(Boolean).slice(-1)[0] || id) : id;
            return normalizePersonBaseName(leaf);
        }

        function getForcedRahmaSuffix(nodeId, branchKey) {
            const base = normalizePersonName(getLeafBaseNameFromNodeId(nodeId));
            if (!base) return "";
            const suffix = FORCED_RAHMA_BY_BASE[base] || "";
            if (!suffix) return "";
            const branch = normalizePersonName(branchKey || state.branch || "");
            if (!branch) return "";
            const byBranch = state.forcedRahmaByBranch && state.forcedRahmaByBranch[branch] ? state.forcedRahmaByBranch[branch] : null;
            if (!byBranch) return "";
            const canonicalId = normalizePersonName(byBranch[base] || "");
            if (!canonicalId) return "";
            const id = normalizePersonName(nodeId || "");
            return id === canonicalId ? suffix : "";
        }

        function buildLineagePlanFromTokens(tokens, branchKey, selectedParent) {
            const t = Array.isArray(tokens) ? tokens.map((x) => normalizePersonName(x)).filter(Boolean) : [];
            if (t.length < 2) return null;

            const branch = normalizePersonName(branchKey || "");
            if (branch && t.length >= 3) {
                const a = normalizePersonName(t[t.length - 3] || "");
                const b = normalizePersonName(t[t.length - 2] || "");
                const c = normalizePersonName(t[t.length - 1] || "");
                if (a === branch && b === "مطلق" && c === "زيدان") {
                    const relative = t.slice(0, -3);
                    if (!relative.length) return null;
                    const branchRoot = getBranchRootName(branch);
                    const chain = relative.reverse();
                    return { anchorParent: branchRoot, chain };
                }
            }

            const anchorBranchIndex = branch ? t.lastIndexOf(branch) : -1;
            if (anchorBranchIndex >= 0) {
                const relative = t.slice(0, anchorBranchIndex);
                if (!relative.length) return null;
                const branchRoot = getBranchRootName(branch);
                const chain = relative.reverse();
                return { anchorParent: branchRoot, chain };
            }

            const selected = normalizePersonName(selectedParent || "");
            const selectedBase = normalizePersonBaseName(selected);
            const last = normalizePersonName(t[t.length - 1] || "");
            if (selected && selectedBase && selectedBase === last) {
                const relative = t.slice(0, -1);
                if (!relative.length) return null;
                return { anchorParent: selected, chain: relative.reverse() };
            }

            return null;
        }

        function getParentShortNameForDisambiguation(parentName) {
            const n = normalizePersonName(parentName || "");
            const cleaned = n.replace(/^أصل الفرع:\s*/i, "").trim();
            if (!cleaned) return "";
            const first = cleaned.split(" ")[0];
            return first || cleaned;
        }

        function getAllBaseNames() {
            const baseNames = new Set();
            Object.keys(state.children || {}).forEach((p) => {
                const b = normalizePersonBaseName(p);
                if (b) baseNames.add(b);
            });
            Object.values(state.children || {}).forEach((list) => {
                (Array.isArray(list) ? list : []).forEach((c) => {
                    const b = normalizePersonBaseName(c && c.name ? c.name : "");
                    if (b) baseNames.add(b);
                });
            });
            return baseNames;
        }

        function computeUniqueChildName(parentName, desiredName, birthYear, baseNames) {
            const name = normalizePersonName(desiredName || "");
            const inputBase = normalizePersonBaseName(name);
            if (!inputBase) return "";
            if (!baseNames || !baseNames.has(inputBase)) return name;

            const parentShort = getParentShortNameForDisambiguation(parentName);
            const tag = birthYear ? ("مواليد " + birthYear) : ("ابن " + (parentShort || parentName));
            let candidate = inputBase + " (" + tag + ")";
            let i = 2;
            while (baseNames.has(normalizePersonBaseName(candidate))) {
                candidate = inputBase + " (" + tag + " " + String(i) + ")";
                i += 1;
            }
            return candidate;
        }

        function findChildNameByBase(parentName, childBase) {
            const key = normalizePersonName(parentName || "");
            const base = normalizePersonName(childBase || "");
            const existing = state.children[key] || [];
            const hit = (Array.isArray(existing) ? existing : []).find((c) => normalizePersonBaseName(c && c.name ? c.name : "") === base);
            return hit && hit.name ? normalizePersonName(hit.name) : "";
        }

        function pickText(arr) {
            if (!arr || !arr.length) return "";
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function formatDateISO(v) {
            let s = String(v || "").trim();
            if (!s) return "";
            for (let i = 0; i < 3; i++) {
                const m = /^\s*[\(（]\s*(.*?)\s*[\)）]\s*$/.exec(s);
                if (!m) break;
                s = String(m[1] || "").trim();
                if (!s) return "";
            }
            const toLooseIso = (y, mo, d) => String(parseInt(y, 10)) + "-" + String(parseInt(mo, 10)) + "-" + String(parseInt(d, 10));
            const slash = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
            if (slash) {
                const d = slash[1].padStart(2, "0");
                const m = slash[2].padStart(2, "0");
                const y = slash[3];
                const year = parseInt(y, 10);
                if (year >= 1200 && year <= 1700) return toLooseIso(y, m, d);
                const hijriISO = gregorianToHijriISO(y + "-" + m + "-" + d);
                const h = parseHijriISO(hijriISO);
                if (h) return toLooseIso(String(h.y), String(h.mo), String(h.d));
                return y + "-" + String(parseInt(m, 10)) + "-" + String(parseInt(d, 10));
            }
            const iso = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s);
            if (iso) {
                const y = iso[1].padStart(4, "0");
                const m = iso[2].padStart(2, "0");
                const d = iso[3].padStart(2, "0");
                const year = parseInt(y, 10);
                if (year >= 1200 && year <= 1700) return toLooseIso(y, m, d);
                const hijriISO = gregorianToHijriISO(y + "-" + m + "-" + d);
                const h = parseHijriISO(hijriISO);
                if (h) return toLooseIso(String(h.y), String(h.mo), String(h.d));
                return y + "-" + String(parseInt(m, 10)) + "-" + String(parseInt(d, 10));
            }
            return s;
        }

        function todayGregorianISO() {
            const now = new Date();
            const y = String(now.getFullYear()).padStart(4, "0");
            const m = String(now.getMonth() + 1).padStart(2, "0");
            const d = String(now.getDate()).padStart(2, "0");
            return y + "-" + m + "-" + d;
        }

        function wrapLTRText(v) {
            const s = String(v || "");
            if (!s) return "";
            return "\u200E" + s + "\u200E";
        }

        function formatTime12Ar(v) {
            const s = String(v || "").trim();
            if (!s) return "";
            const m = /^(\d{1,2}):(\d{2})(?::\d{2})?$/.exec(s);
            if (!m) return s;
            let h = parseInt(m[1], 10);
            const min = m[2];
            if (!Number.isFinite(h)) return s;
            const suffix = h >= 12 ? "مساءً" : "صباحاً";
            h = h % 12;
            if (h === 0) h = 12;
            return String(h) + ":" + min + " " + suffix;
        }

        function formatEventText(event) {
            const name = event.person || "";
            if (event.type === "birth") {
                return pickText([
                    "ألف مبروك لـ " + name + " بمولود جديد، جعله الله من مواليد السعادة.",
                    "نبارك لـ " + name + " قدوم المولود، وجعله الله قرة عين لوالديه.",
                    "نبارك لـ " + name + " المولود الجديد، اللهم أنبته نباتًا حسنًا."
                ]);
            }
            if (event.type === "engagement") {
                return pickText([
                    "نبارك لـ " + name + " الخطوبة، ونسأل الله تمام الفرح.",
                    "ألف مبروك لـ " + name + " الخطوبة، عقبال ليلة العمر.",
                    "نبارك لـ " + name + " الخطوبة، وجمع الله بين القلوب على خير."
                ]);
            }
            if (event.type === "contract") {
                return pickText([
                    "نبارك لـ " + name + " عقد القران، ونسأل الله لهما البركة والتوفيق.",
                    "ألف مبروك لـ " + name + " عقد القران، جعله الله عقدًا مباركًا.",
                    "نبارك لـ " + name + " عقد القران، ونسأل الله حياةً سعيدة."
                ]);
            }
            if (event.type === "marriage") {
                return pickText([
                    "نبارك لـ " + name + " الزواج، ونسأل الله لهما السعادة والهناء.",
                    "ألف مبروك لـ " + name + " الزواج، عسى الفرح يدوم.",
                    "نبارك لـ " + name + " الزواج، وجمع الله بينهما على خير."
                ]);
            }
            if (event.type === "graduation") {
                return pickText([
                    "نبارك لـ " + name + " التخرّج، ومنها للأعلى بإذن الله.",
                    "ألف مبروك لـ " + name + " التخرّج، نجاح يرفع الرأس.",
                    "نبارك لـ " + name + " التخرّج، وعقبال المنصب الأعلى."
                ]);
            }
            if (event.type === "success") {
                return pickText([
                    "نبارك لـ " + name + " النجاح والتفوق، عقبال أعلى المراتب.",
                    "ألف مبروك لـ " + name + " التفوق، هذا ثمرة الجد والاجتهاد.",
                    "نبارك لـ " + name + " النجاح، جعلها فاتحة خير."
                ]);
            }
            if (event.type === "promotion") {
                return pickText([
                    "نبارك لـ " + name + " الترقية/الوظيفة الجديدة، الله يبارك لك ويوفقك.",
                    "ألف مبروك لـ " + name + " الترقية، تستاهل كل خير.",
                    "نبارك لـ " + name + " الوظيفة الجديدة، ومنها للأعلى."
                ]);
            }
            if (event.type === "new_house") {
                return pickText([
                    "نبارك لـ " + name + " المنزل الجديد، جعله الله منزلًا مباركًا عامرًا بالطاعة.",
                    "ألف مبروك لـ " + name + " المنزل الجديد، عسى السعادة تملأ أركانه.",
                    "نبارك لـ " + name + " البيت الجديد، جعله الله دار فرح وراحة."
                ]);
            }
            if (event.type === "travel") {
                return pickText([
                    "نتمنى لـ " + name + " سفرًا موفقًا وعودة سالمة.",
                    "في حفظ الله يا " + name + "، سفر سعيد وعودة قريبة.",
                    "نسأل الله التوفيق لـ " + name + " في السفر والسلامة في الرجوع."
                ]);
            }
            if (event.type === "gathering") {
                return pickText([
                    "دعوة لاجتماع عائلي — حضوركم يسعدنا ويزيد اللمة بهجة.",
                    "لقاء عائلي قريب — اللمة تجمعنا على خير ومحبة.",
                    "اجتماع عائلي — موعد يجمع القلوب ويقوّي صلة الرحم."
                ]);
            }
            if (event.type === "death") {
                return "عزاء: " + name + " — عظم الله أجركم وأحسن الله عزاءكم.";
            }
            if (event.type === "sick") {
                return "نسأل الله الشفاء العاجل لـ " + name + "، لا بأس طهور إن شاء الله.";
            }
            if (event.type === "operation") {
                return "نسأل الله الشفاء لـ " + name + " بعد العملية، ونسألكم الدعاء له.";
            }
            if (event.type === "discharge") {
                return pickText([
                    "الحمد لله على سلامة " + name + " وخروجه من المستشفى، طهور إن شاء الله.",
                    "ألف الحمد لله على سلامة " + name + "، نسأل الله أن يتمم عليه الصحة والعافية.",
                    "الحمد لله على سلامة " + name + "، ونسأل الله أن يجعل ما أصابه كفارة."
                ]);
            }
            return name ? name : "";
        }

        const happySection = document.querySelector('#events-card details.toggle-card[data-kind="happy"]');
        const sickSection = document.querySelector('#events-card details.toggle-card[data-kind="sick"]');
        const deathSection = document.querySelector('#events-card details.toggle-card[data-kind="death"]');

        let editingHappy = null;
        let editingSick = null;
        let editingDeath = null;

        function showAlert(el, kind, text) {
            if (!el) return;
            el.textContent = String(text || "");
            el.className = "alert " + (kind === "success" ? "alert-success" : "alert-error");
            el.style.display = "block";
        }

        function showAlertAndFocus(el, kind, text) {
            showAlert(el, kind, text);
            try {
                if (el && typeof el.scrollIntoView === "function") {
                    el.scrollIntoView({ block: "start", behavior: "smooth" });
                }
            } catch (e) {}
        }

        function hideAlert(el) {
            if (!el) return;
            el.style.display = "none";
        }

        function getEventPk(row) {
            if (row && row.id != null) return { col: "id", value: row.id };
            if (row && row.created_at != null) return { col: "created_at", value: row.created_at };
            return null;
        }

        function getEventPkKeys(row) {
            const keys = [];
            if (row && row.id != null) keys.push("id:" + String(row.id));
            if (row && row.created_at != null) keys.push("created_at:" + String(row.created_at));
            return keys;
        }

        function getEventPkRefs(row) {
            const refs = [];
            if (row && row.id != null) refs.push({ col: "id", value: row.id });
            if (row && row.created_at != null) refs.push({ col: "created_at", value: row.created_at });
            return refs;
        }

        function addEnvelopePkRefsToSet(refOrRefs, set) {
            if (!set) return;
            const addOne = (ref) => {
                if (!ref || !ref.col || ref.value == null) return;
                set.add(String(ref.col) + ":" + String(ref.value));
            };
            if (Array.isArray(refOrRefs)) {
                refOrRefs.forEach((r) => addOne(r));
                return;
            }
            addOne(refOrRefs);
        }

        function parseHealthDetails(eventRow) {
            const parsed = safeParseJson(eventRow && eventRow.details != null ? eventRow.details : null);
            if (parsed && typeof parsed === "object" && parsed.kind === "health_notice" && parsed.v === 1) {
                return {
                    place: String(parsed.place || "hospital").trim() === "home" ? "home" : "hospital",
                    homeCity: String(parsed.homeCity || "").trim(),
                    homeArea: String(parsed.homeArea || "").trim(),
                    notes: String(parsed.notes || "").trim(),
                    hospitalName: String(parsed.hospitalName || "").trim(),
                    hospitalDept: String(parsed.hospitalDept || "").trim()
                };
            }
            const raw = String(eventRow && eventRow.details != null ? eventRow.details : "").trim();
            return {
                place: "hospital",
                homeCity: "",
                homeArea: "",
                notes: raw,
                hospitalName: "",
                hospitalDept: ""
            };
        }

        function updateSickContactModeVisibility() {
            if (!sickContactMethod || !sickVisitBlock || !sickContactBlock) return;
            const mode = sickContactMethod.value;
            const isVisit = mode === "visit";
            sickVisitBlock.style.display = isVisit ? "block" : "none";
            sickContactBlock.style.display = isVisit ? "none" : "block";
            if (isVisit) {
                if (sickContactPhone) sickContactPhone.value = "";
                syncVisitTimeHidden(sickVisitTimeFromHour, sickVisitTimeFromMinute, sickVisitTimeFromPeriod, sickVisitTimeFrom);
                syncVisitTimeHidden(sickVisitTimeToHour, sickVisitTimeToMinute, sickVisitTimeToPeriod, sickVisitTimeTo);
            } else {
                if (sickVisitDateFrom) sickVisitDateFrom.value = "";
                if (sickVisitDateTo) sickVisitDateTo.value = "";
                if (sickVisitTimeFrom) sickVisitTimeFrom.value = "";
                if (sickVisitTimeTo) sickVisitTimeTo.value = "";
                if (sickVisitTimeFromHour) sickVisitTimeFromHour.value = "";
                if (sickVisitTimeFromMinute) sickVisitTimeFromMinute.value = "";
                if (sickVisitTimeFromPeriod) sickVisitTimeFromPeriod.value = "";
                if (sickVisitTimeToHour) sickVisitTimeToHour.value = "";
                if (sickVisitTimeToMinute) sickVisitTimeToMinute.value = "";
                if (sickVisitTimeToPeriod) sickVisitTimeToPeriod.value = "";
            }
        }

        function updateSickPlaceVisibility() {
            if (!sickPlace || !sickHospitalFields || !sickHomeFields) return;
            const place = sickPlace.value === "home" ? "home" : "hospital";
            const isHome = place === "home";
            sickHospitalFields.style.display = isHome ? "none" : "block";
            sickHomeFields.style.display = isHome ? "block" : "none";
            if (isHome) {
                if (sickHospitalName) sickHospitalName.value = "";
                if (sickHospitalDept) sickHospitalDept.value = "";
            } else {
                if (sickHomeCity) sickHomeCity.value = "";
                if (sickHomeArea) sickHomeArea.value = "";
            }
        }

        function buildVisitTimeValue(hourEl, minuteEl, periodEl) {
            const hourRaw = String(hourEl && hourEl.value != null ? hourEl.value : "").trim();
            const minuteRaw = String(minuteEl && minuteEl.value != null ? minuteEl.value : "").trim();
            const periodRaw = String(periodEl && periodEl.value != null ? periodEl.value : "").trim().toLowerCase();
            if (!hourRaw || !minuteRaw || !periodRaw) return "";
            const hour12 = parseInt(hourRaw, 10);
            const minute = parseInt(minuteRaw, 10);
            if (!Number.isFinite(hour12) || hour12 < 1 || hour12 > 12) return "";
            if (!Number.isFinite(minute) || minute < 0 || minute > 59) return "";
            if (periodRaw !== "am" && periodRaw !== "pm") return "";
            let hour24 = hour12 % 12;
            if (periodRaw === "pm") hour24 += 12;
            return String(hour24).padStart(2, "0") + ":" + String(minute).padStart(2, "0");
        }

        function syncVisitTimeHidden(hourEl, minuteEl, periodEl, hiddenEl) {
            if (!hiddenEl) return;
            hiddenEl.value = buildVisitTimeValue(hourEl, minuteEl, periodEl);
        }

        function setVisitTimeSelectorsFromValue(hourEl, minuteEl, periodEl, timeValue) {
            const s = String(timeValue || "").trim();
            if (!hourEl || !minuteEl || !periodEl) return;
            if (!s) {
                hourEl.value = "";
                minuteEl.value = "";
                periodEl.value = "";
                return;
            }
            const m = /^(\d{1,2}):(\d{2})(?::\d{2})?$/.exec(s);
            if (!m) return;
            const hour24 = parseInt(m[1], 10);
            const minute = parseInt(m[2], 10);
            if (!Number.isFinite(hour24) || hour24 < 0 || hour24 > 23) return;
            if (!Number.isFinite(minute) || minute < 0 || minute > 59) return;
            const period = hour24 >= 12 ? "pm" : "am";
            const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;
            hourEl.value = String(hour12);
            minuteEl.value = String(minute).padStart(2, "0");
            periodEl.value = period;
        }

        function buildVisitMeta(event) {
            const contactMethodValue = event.contactMethod || event.contact_method || "";
            const contactPhoneValue = event.contactPhone || event.contact_phone || "";
            const visitDateFromValue = event.visitDateFromLabel || event.visit_date_from || "";
            const visitDateToValue = event.visitDateToLabel || event.visit_date_to || "";
            const visitTimeFromValue = event.visitTimeFrom || event.visit_time_from || "";
            const visitTimeToValue = event.visitTimeTo || event.visit_time_to || "";
            if (contactMethodValue === "visit") {
                const dateFrom = visitDateFromValue || "";
                const dateTo = visitDateToValue || "";
                const timeFrom = visitTimeFromValue || "";
                const timeTo = visitTimeToValue || "";
                const visitParts = [];
                if (dateFrom || dateTo) {
                    const fromLabel = dateFrom ? formatDateISO(dateFrom) : "";
                    const toLabel = dateTo ? formatDateISO(dateTo) : "";
                    if (fromLabel && toLabel) visitParts.push("من " + wrapLTRText(fromLabel) + " إلى " + wrapLTRText(toLabel));
                    else if (fromLabel) visitParts.push("من " + wrapLTRText(fromLabel));
                    else if (toLabel) visitParts.push("إلى " + wrapLTRText(toLabel));
                }
                if (timeFrom || timeTo) {
                    const fromLabel = timeFrom ? formatTime12Ar(timeFrom) : "";
                    const toLabel = timeTo ? formatTime12Ar(timeTo) : "";
                    if (fromLabel && toLabel) visitParts.push("من " + fromLabel + " إلى " + toLabel);
                    else if (fromLabel) visitParts.push("من " + fromLabel);
                    else visitParts.push("إلى " + toLabel);
                }
                return visitParts.length ? ("الزيارة: " + visitParts.join(" – ")) : "";
            }
            if (contactMethodValue === "call") {
                return contactPhoneValue ? ("التواصل: اتصال – الجوال: " + contactPhoneValue) : "التواصل: اتصال";
            }
            if (contactMethodValue === "whatsapp") {
                return contactPhoneValue ? ("التواصل: واتساب – الجوال: " + contactPhoneValue) : "التواصل: واتساب";
            }
            return "";
        }

        function createEventActions(rowData, onEdit, onDelete) {
            const wrap = document.createElement("div");
            wrap.className = "row-actions";
            const pk = getEventPk(rowData);
            if (!pk) {
                const hint = document.createElement("div");
                hint.className = "hint";
                hint.textContent = "لا يمكن التعديل/الحذف لأن معرف السجل غير متوفر.";
                wrap.appendChild(hint);
                return wrap;
            }
            const editBtn = document.createElement("button");
            editBtn.type = "button";
            editBtn.className = "btn btn-secondary btn-small";
            editBtn.textContent = "تعديل";
            editBtn.addEventListener("click", () => onEdit(rowData));
            const delBtn = document.createElement("button");
            delBtn.type = "button";
            delBtn.className = "btn btn-secondary btn-small";
            delBtn.textContent = "حذف";
            delBtn.addEventListener("click", () => onDelete(rowData));
            wrap.appendChild(editBtn);
            wrap.appendChild(delBtn);
            return wrap;
        }

        function renderHappyEvents() {
            if (!happyList) return;
            happyList.innerHTML = "";
            const list = Array.isArray(state.happyEvents) ? state.happyEvents : [];
            if (!list.length) {
                const empty = document.createElement("div");
                empty.className = "hint";
                empty.textContent = "لا توجد أفراح مسجلة.";
                happyList.appendChild(empty);
                return;
            }
            list.slice().reverse().forEach((event) => {
                const row = document.createElement("div");
                row.className = "event-row";
                const main = document.createElement("div");
                main.textContent = formatEventText(event);
                row.appendChild(main);

                const metaParts = [];
                const dateRaw = String(event && (event.event_date || event.eventDate || event.date_label || event.dateLabel) ? (event.event_date || event.eventDate || event.date_label || event.dateLabel) : "").trim();
                const dateLabel = dateRaw ? formatDateISO(dateRaw) : "";
                if (dateLabel) metaParts.push("التاريخ: " + wrapLTRText(dateLabel));
                const detailsText = getHappyDetailsText(event || {});
                if (detailsText) metaParts.push(detailsText);
                if (metaParts.length) {
                    const meta = document.createElement("div");
                    meta.className = "event-meta";
                    meta.textContent = metaParts.join(" – ");
                    row.appendChild(meta);
                }

                row.appendChild(
                    createEventActions(
                        event,
                        (r) => startEditHappy(r),
                        (r) => deleteEventRow(r, { kind: "happy", rowEl: row })
                    )
                );
                happyList.appendChild(row);
            });
        }

        function renderSickEvents() {
            if (!sickList) return;
            sickList.innerHTML = "";
            const list = Array.isArray(state.sickEvents) ? state.sickEvents : [];
            if (!list.length) {
                const empty = document.createElement("div");
                empty.className = "hint";
                empty.textContent = "لا توجد أخبار مرضى مسجلة.";
                sickList.appendChild(empty);
                return;
            }
            list.slice().reverse().forEach((event) => {
                const row = document.createElement("div");
                row.className = "event-row";
                const main = document.createElement("div");
                main.textContent = formatEventText(event);
                row.appendChild(main);

                const metaParts = [];
                const dateRaw = String(event && (event.event_date || event.eventDate || event.date_label || event.dateLabel) ? (event.event_date || event.eventDate || event.date_label || event.dateLabel) : "").trim();
                const dateLabel = dateRaw ? formatDateISO(dateRaw) : "";
                if (dateLabel) metaParts.push("التاريخ: " + wrapLTRText(dateLabel));

                const health = parseHealthDetails(event || {});
                const hospitalNameValue = String(event.hospitalName || event.hospital_name || health.hospitalName || "").trim();
                const hospitalDeptValue = String(event.hospitalDept || event.hospital_dept || health.hospitalDept || "").trim();

                if (health.place === "home") {
                    metaParts.push("المكان: المنزل");
                    if (health.homeCity) metaParts.push("المدينة: " + health.homeCity);
                    if (health.homeArea) metaParts.push("الموقع: " + health.homeArea);
                } else {
                    if (hospitalNameValue) metaParts.push("المستشفى: " + hospitalNameValue);
                    if (hospitalDeptValue) metaParts.push("القسم: " + hospitalDeptValue);
                }

                const visitMeta = buildVisitMeta(event || {});
                if (visitMeta) metaParts.push(visitMeta);
                if (health.notes) metaParts.push(health.notes);

                if (metaParts.length) {
                    const meta = document.createElement("div");
                    meta.className = "event-meta";
                    meta.textContent = metaParts.join(" – ");
                    row.appendChild(meta);
                }

                row.appendChild(
                    createEventActions(
                        event,
                        (r) => startEditSick(r),
                        (r) => deleteEventRow(r, { kind: "sick", rowEl: row })
                    )
                );
                sickList.appendChild(row);
            });
        }

        async function loadEventsForBranch(branchKey) {
            const sb = getSupabaseClient();
            if (!sb) {
                showAlert(happyAlert, "error", "تعذر تحميل المناسبات لأن الربط غير مُعد.");
                showAlert(sickAlert, "error", "تعذر تحميل المناسبات لأن الربط غير مُعد.");
                return false;
            }
            const { data, error } = await sb
                .from("family_events")
                .select("*")
                .eq("branch_key", branchKey)
                .order("created_at", { ascending: false })
                .limit(300);
            if (error) {
                showAlert(happyAlert, "error", `تعذر تحميل المناسبات: ${error.message || "خطأ غير معروف"}`);
                showAlert(sickAlert, "error", `تعذر تحميل المناسبات: ${error.message || "خطأ غير معروف"}`);
                return false;
            }
            hideAlert(happyAlert);
            hideAlert(sickAlert);
            const rowsRaw = (Array.isArray(data) ? data : []).filter((e) => String(e && e.type ? e.type : "") !== "death");
            const tombstonedKeys = new Set();
            const replacedKeys = new Set();
            rowsRaw.forEach((r) => {
                const env = parseEventEnvelope(r);
                if (env && env.kind === "event_tombstone") {
                    addEnvelopePkRefsToSet(env.target, tombstonedKeys);
                    addEnvelopePkRefsToSet(env.targetKeys, tombstonedKeys);
                    return;
                }
                if (env && env.replaces) {
                    addEnvelopePkRefsToSet(env.replaces, replacedKeys);
                    addEnvelopePkRefsToSet(env.replacesKeys, replacedKeys);
                }
            });
            const rows = rowsRaw.filter((r) => {
                const env = parseEventEnvelope(r);
                if (env && env.kind === "event_tombstone") return false;
                const keys = getEventPkKeys(r);
                if (!keys.length) return true;
                if (keys.some((k) => tombstonedKeys.has(k))) return false;
                if (keys.some((k) => replacedKeys.has(k))) return false;
                return true;
            });
            const happy = [];
            const sick = [];
            rows.forEach((r) => {
                const t = String(r && r.type ? r.type : "").trim();
                if (!t) return;
                if (t === "sick" || t === "operation" || t === "discharge") sick.push(r);
                else happy.push(r);
            });
            state.happyEvents = happy;
            state.sickEvents = sick;
            renderHappyEvents();
            renderSickEvents();
            return true;
        }

        function safeParseJson(v) {
            try {
                if (v == null) return null;
                const s = String(v || "").trim();
                if (!s) return null;
                return JSON.parse(s);
            } catch (e) {
                return null;
            }
        }

        function parseEventEnvelope(eventRow) {
            const parsed = safeParseJson(eventRow && eventRow.details != null ? eventRow.details : null);
            if (parsed && typeof parsed === "object") return parsed;
            return null;
        }

        function clampVisibilityDays(v) {
            const n = parseInt(String(v || "").trim(), 10);
            if (!Number.isFinite(n)) return 7;
            if (n < 1) return 1;
            if (n > 7) return 7;
            return n;
        }

        function getEventVisibilityDays(eventRow) {
            const env = parseEventEnvelope(eventRow || {});
            if (env && env.v === 1 && (env.kind === "happy_notice" || env.kind === "health_notice" || env.kind === "death_notice")) {
                return clampVisibilityDays(env.showDays);
            }
            return 7;
        }

        function getHappyDetailsText(eventRow) {
            const env = parseEventEnvelope(eventRow || {});
            if (env && env.kind === "happy_notice" && env.v === 1) {
                const extra = String(env.extra || "").trim();
                if (extra) return extra;
                return String(env.text || "").trim();
            }
            return String(eventRow && eventRow.details != null ? eventRow.details : "").trim();
        }

        function normalizePhonesForDisplay(list) {
            const out = [];
            const seen = new Set();
            (Array.isArray(list) ? list : []).forEach((p) => {
                const s = normalizePhone(String(p || ""));
                if (!s) return;
                if (seen.has(s)) return;
                seen.add(s);
                out.push(s);
            });
            return out;
        }

        function parseDeathDetails(eventRow) {
            const parsed = safeParseJson(eventRow && eventRow.details != null ? eventRow.details : null);
            if (parsed && typeof parsed === "object" && parsed.kind === "death_notice" && parsed.v === 1) {
                return {
                    prayerPlace: normalizePersonName(parsed.prayerPlace || ""),
                    prayerTime: normalizePersonName(parsed.prayerTime || ""),
                    burialPlace: normalizePersonName(parsed.burialPlace || ""),
                    burialTime: normalizePersonName(parsed.burialTime || ""),
                    condolencePlace: normalizePersonName(parsed.condolencePlace || ""),
                    condolenceTime: normalizePersonName(parsed.condolenceTime || ""),
                    phones: normalizePhonesForDisplay(parsed.phones || []),
                    notes: String(parsed.notes || "").trim()
                };
            }
            const raw = String(eventRow && eventRow.details != null ? eventRow.details : "").trim();
            return {
                prayerPlace: "",
                prayerTime: "",
                burialPlace: "",
                burialTime: "",
                condolencePlace: "",
                condolenceTime: "",
                phones: [],
                notes: raw
            };
        }

        function renderDeaths() {
            deathsList.innerHTML = "";
            if (!state.deaths.length) {
                const empty = document.createElement("div");
                empty.className = "hint";
                empty.textContent = "لا توجد أخبار وفاة مسجلة.";
                deathsList.appendChild(empty);
                return;
            }
            state.deaths.slice().reverse().forEach((deathRow) => {
                const row = document.createElement("div");
                row.className = "event-row";

                const person = normalizePersonName(deathRow && deathRow.person ? deathRow.person : "");
                const title = document.createElement("div");
                title.textContent = person ? ("خبر وفاة: " + person) : "خبر وفاة";
                row.appendChild(title);

                const dateRaw = String(deathRow && (deathRow.event_date || deathRow.eventDate || deathRow.date_label || deathRow.dateLabel) ? (deathRow.event_date || deathRow.eventDate || deathRow.date_label || deathRow.dateLabel) : "").trim();
                const dateLabel = dateRaw ? formatDateISO(dateRaw) : "";
                const metaParts = [];
                if (dateLabel) metaParts.push("التاريخ: " + wrapLTRText(dateLabel));

                const d = parseDeathDetails(deathRow || {});
                if (d.prayerPlace) metaParts.push("الصلاة: " + d.prayerPlace + (d.prayerTime ? (" (" + d.prayerTime + ")") : ""));
                else if (d.prayerTime) metaParts.push("الصلاة: " + d.prayerTime);
                if (d.burialPlace) metaParts.push("الدفن: " + d.burialPlace + (d.burialTime ? (" (" + d.burialTime + ")") : ""));
                else if (d.burialTime) metaParts.push("الدفن: " + d.burialTime);
                if (d.condolencePlace) metaParts.push("العزاء: " + d.condolencePlace + (d.condolenceTime ? (" (" + d.condolenceTime + ")") : ""));
                else if (d.condolenceTime) metaParts.push("العزاء: " + d.condolenceTime);
                if (d.phones.length) metaParts.push("التواصل: " + d.phones.join(" / "));
                if (d.notes) metaParts.push(d.notes);

                if (metaParts.length) {
                    const meta = document.createElement("div");
                    meta.className = "event-meta";
                    meta.textContent = metaParts.join(" – ");
                    row.appendChild(meta);
                }

                row.appendChild(
                    createEventActions(
                        deathRow,
                        (r) => startEditDeath(r),
                        (r) => deleteEventRow(r, { kind: "death", rowEl: row })
                    )
                );
                deathsList.appendChild(row);
            });
        }

        async function loadDeathsForBranch(branchKey) {
            const sb = getSupabaseClient();
            if (!sb) {
                if (deathAlert) {
                    deathAlert.textContent = "تعذر تحميل أخبار الوفاة لأن الربط غير مُعد.";
                    deathAlert.className = "alert alert-error";
                    deathAlert.style.display = "block";
                }
                return false;
            }
            const { data, error } = await sb
                .from("family_events")
                .select("*")
                .eq("branch_key", branchKey)
                .eq("type", "death")
                .order("created_at", { ascending: false })
                .limit(200);
            if (error) {
                if (deathAlert) {
                    deathAlert.textContent = `تعذر تحميل أخبار الوفاة: ${error.message || "خطأ غير معروف"}`;
                    deathAlert.className = "alert alert-error";
                    deathAlert.style.display = "block";
                }
                return false;
            }
            const rowsRaw = Array.isArray(data) ? data : [];
            const tombstonedKeys = new Set();
            const replacedKeys = new Set();
            rowsRaw.forEach((r) => {
                const env = parseEventEnvelope(r);
                if (env && env.kind === "event_tombstone") {
                    addEnvelopePkRefsToSet(env.target, tombstonedKeys);
                    addEnvelopePkRefsToSet(env.targetKeys, tombstonedKeys);
                    return;
                }
                if (env && env.replaces) {
                    addEnvelopePkRefsToSet(env.replaces, replacedKeys);
                    addEnvelopePkRefsToSet(env.replacesKeys, replacedKeys);
                }
            });
            state.deaths = rowsRaw.filter((r) => {
                const env = parseEventEnvelope(r);
                if (env && env.kind === "event_tombstone") return false;
                const keys = getEventPkKeys(r);
                if (!keys.length) return true;
                if (keys.some((k) => tombstonedKeys.has(k))) return false;
                if (keys.some((k) => replacedKeys.has(k))) return false;
                return true;
            });
            if (deathAlert) deathAlert.style.display = "none";
            renderDeaths();
            return true;
        }

        function startBranch(branchKey) {
            if (!branchKey || !Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) {
                setLoginAlert("error", "يرجى اختيار الفرع بشكل صحيح.");
                return false;
            }
            applyView("delegate");
            hideLoginAlert();
            state.branch = branchKey;
            branchTitle.textContent = "لوحة فرع " + branchKey + " بن مطلق بن زيدان";
            loginCard.style.display = "none";
            dashboardCard.style.display = "block";
            if (eventsCard) eventsCard.style.display = "block";
            loadChildrenForBranch(branchKey, { applyToState: true })
                .then(() => {
                    renderParentsForBranch(branchKey);
                    if (desiredParentFromUrl) {
                        selectParentForAdding(desiredParentFromUrl);
                    } else {
                        const root = getBranchRootName(branchKey);
                        if (root) {
                            ensureParentOption(root);
                            parentSelect.value = root;
                        }
                    }
                    renderChildrenForParent(parentSelect.value);
                })
                .catch(() => {});
            loadEventsForBranch(branchKey);
            loadDeathsForBranch(branchKey);
            return true;
        }

        async function pushDelegateRequestToSupabase(payload, msg, secretHash) {
            const sb = getSupabaseClient();
            if (!sb) return { ok: false, reason: "not_configured" };

            const statusesToBlock = ["pending", "approved"];
            const branchKey = payload.branch;
            const phone = String(payload.phone || "").trim();
            const email = String(payload.email || "").trim();
            let uniquenessCheckWorked = false;
            let uniquenessCheckBlocked = false;
            const pickNewer = (a, b) => {
                if (!a) return b || null;
                if (!b) return a || null;
                const at = String(a.created_at || "");
                const bt = String(b.created_at || "");
                return bt > at ? b : a;
            };

            const matches = { phone: null, email: null };
            const isUniquenessQueryBlockedError = (err) => {
                const msgRaw = err && err.message != null ? String(err.message) : "";
                const detailsRaw = err && err.details != null ? String(err.details) : "";
                const low = (msgRaw + " " + detailsRaw).toLowerCase();
                return (
                    low.includes("row-level security") ||
                    low.includes("violates row-level security") ||
                    low.includes("permission denied") ||
                    low.includes("not authorized") ||
                    low.includes("not allowed")
                );
            };
            const isRpcMissingError = (err) => {
                const msgRaw = err && err.message != null ? String(err.message) : "";
                const low = msgRaw.toLowerCase();
                return low.includes("could not find the function") || (low.includes("function") && low.includes("does not exist"));
            };

            const checkViaRpc = async () => {
                try {
                    const { data, error } = await sb.rpc("tree_delegate_find_conflict_v1", {
                        p_phone: phone || null,
                        p_email: email || null
                    });
                    if (error) {
                        if (isRpcMissingError(error)) return;
                        return;
                    }
                    const row = Array.isArray(data) ? data[0] : data;
                    if (!row) {
                        uniquenessCheckWorked = true;
                        return;
                    }
                    uniquenessCheckWorked = true;
                    const status = String(row.status || "").trim();
                    const conflictBranch = String(row.branch_key || "").trim();
                    const requestId = String(row.request_id || "").trim();
                    if (!status || !statusesToBlock.includes(status)) return;
                    if (status === "pending") {
                        matches.phone = matches.phone || { status: "pending", branch_key: conflictBranch, request_id: requestId, created_at: row.created_at || "" };
                        matches.email = matches.email || { status: "pending", branch_key: conflictBranch, request_id: requestId, created_at: row.created_at || "" };
                        return;
                    }
                    if (status === "approved") {
                        matches.phone = matches.phone || { status: "approved", branch_key: conflictBranch, request_id: requestId, created_at: row.created_at || "" };
                        matches.email = matches.email || { status: "approved", branch_key: conflictBranch, request_id: requestId, created_at: row.created_at || "" };
                    }
                } catch (e) {}
            };

            const checkPhone = async () => {
                if (!phone) return;
                const candidates = phoneCandidates(phone);
                if (!candidates.length) return;
                const { data, error } = await sb
                    .from("approval_requests")
                    .select("request_id,status,secret_hash,created_at,phone,email,branch_key")
                    .eq("kind", "tree_delegate")
                    .in("phone", candidates)
                    .in("status", statusesToBlock)
                    .order("created_at", { ascending: false })
                    .limit(100);
                if (error) {
                    if (isUniquenessQueryBlockedError(error)) uniquenessCheckBlocked = true;
                    return;
                }
                if (!data || !data.length) {
                    uniquenessCheckWorked = true;
                    return;
                }
                uniquenessCheckWorked = true;
                const normalized = normalizePhone(phone);
                const found = data.find((r) => normalizePhone(r.phone) === normalized) || null;
                matches.phone = found;
            };
            const checkEmail = async () => {
                if (!email) return;
                const { data, error } = await sb
                    .from("approval_requests")
                    .select("request_id,status,secret_hash,created_at,phone,email,branch_key")
                    .eq("kind", "tree_delegate")
                    .ilike("email", normalizeEmail(email))
                    .in("status", statusesToBlock)
                    .order("created_at", { ascending: false })
                    .limit(100);
                if (error) {
                    if (isUniquenessQueryBlockedError(error)) uniquenessCheckBlocked = true;
                    return;
                }
                if (!data || !data.length) {
                    uniquenessCheckWorked = true;
                    return;
                }
                uniquenessCheckWorked = true;
                const normalized = normalizeEmail(email);
                const found = data.find((r) => normalizeEmail(r.email) === normalized) || null;
                matches.email = found;
            };

            try {
                await checkViaRpc();
                await checkPhone();
                await checkEmail();
            } catch (e) {}

            if (!uniquenessCheckWorked && uniquenessCheckBlocked) {
                return { ok: false, reason: "uniqueness_unavailable" };
            }

            const pendingFields = [];
            const approvedFields = [];
            let pendingMatch = null;
            let approvedMatch = null;
            if (matches.phone?.status === "pending") {
                pendingFields.push("phone");
                pendingMatch = pickNewer(pendingMatch, matches.phone);
            }
            if (matches.email?.status === "pending") {
                pendingFields.push("email");
                pendingMatch = pickNewer(pendingMatch, matches.email);
            }
            if (matches.phone?.status === "approved") {
                approvedFields.push("phone");
                approvedMatch = pickNewer(approvedMatch, matches.phone);
            }
            if (matches.email?.status === "approved") {
                approvedFields.push("email");
                approvedMatch = pickNewer(approvedMatch, matches.email);
            }

            if (pendingMatch) return { ok: false, reason: "duplicate_pending", fields: pendingFields, existing: pendingMatch, matches };
            if (approvedMatch) return { ok: false, reason: "duplicate_approved", fields: approvedFields, existing: approvedMatch, matches };

            const row = {
                request_id: payload.requestId,
                kind: "tree_delegate",
                branch_key: payload.branch,
                phone: payload.phone,
                email: payload.email,
                secret_hash: secretHash || null,
                message: msg,
                status: "pending",
                created_at: payload.createdAt
            };
            const { error } = await sb.from("approval_requests").insert(row);
            if (error) return { ok: false, reason: "error", error };
            return { ok: true };
        }

        async function requestDelegateAccess(branchKey, phone, email, secret, opts) {
            const options = opts || {};
            const payload = {
                requestId: makeRequestId(),
                status: "pending",
                branch: branchKey,
                phone,
                email,
                secret,
                createdAt: new Date().toISOString()
            };

            const msg = buildDelegateRequestMessage(payload);
            const secretHash = await sha256Hex(secret);
            const pushed = await pushDelegateRequestToSupabase(payload, msg, secretHash);
            if (pushed.ok) {
                await copyText(msg);
                maybeOpenEmailDraft("طلب مندوب شجرة (" + payload.requestId + ")", msg);
                setLoginAlert("success", `تم تسجيل طلب دخول للمراجعة (رقم الطلب: ${payload.requestId}). سيتم التحقق من الهوية ثم اعتماد الطلب. تم نسخ نص الطلب.`);
                return true;
            }
            if (pushed.reason === "uniqueness_unavailable") {
                setLoginAlert(
                    "error",
                    "لا يمكن التحقق من تكرار الجوال/الإيميل حالياً بسبب صلاحيات قاعدة البيانات. لتطبيق منع التكرار بشكل نهائي: فعّل دالة tree_delegate_find_conflict_v1 أو أضف قيود Unique على الحقول."
                );
                return false;
            }
            if (pushed.reason === "duplicate_pending") {
                const id = pushed.existing?.request_id || "";
                const existingBranch = String(pushed.existing?.branch_key || "").trim();
                const prefix = duplicateFieldsText(pushed.fields);
                setLoginAlert(
                    "success",
                    existingBranch && existingBranch !== branchKey
                        ? id
                            ? `${prefix}. يوجد طلب قيد المراجعة بالفعل لفرع (${existingBranch}) (رقم الطلب: ${id}).`
                            : `${prefix}. يوجد طلب قيد المراجعة بالفعل لفرع (${existingBranch}).`
                        : id
                            ? `${prefix}. طلبك قيد المراجعة بالفعل (رقم الطلب: ${id}).`
                            : `${prefix}. طلبك قيد المراجعة بالفعل.`
                );
                return false;
            }
            if (pushed.reason === "duplicate_approved") {
                const existingBranch = String(pushed.existing?.branch_key || "").trim();
                if (options.forceNew === true) {
                    if (
                        secretHash &&
                        (!pushed.existing?.secret_hash || pushed.existing.secret_hash !== secretHash) &&
                        existingBranch &&
                        existingBranch === branchKey
                    ) {
                        const sb = getSupabaseClient();
                        if (!sb) {
                            setLoginAlert("error", "تعذر إرسال طلب الدخول لأن الربط غير مُعد.");
                            return false;
                        }
                        const existingId = pushed.existing?.request_id;
                        if (!existingId) {
                            setLoginAlert("error", "تعذر تحديث الطلب لأن رقم الطلب السابق غير متوفر.");
                            return false;
                        }
                        const row = {
                            secret_hash: secretHash || null,
                            message: msg,
                            status: "pending",
                            created_at: payload.createdAt
                        };
                        const { error } = await sb.from("approval_requests").update(row).eq("request_id", existingId);
                        if (!error) {
                            await copyText(msg);
                            maybeOpenEmailDraft("تحديث طلب مندوب شجرة (" + existingId + ")", msg);
                            setLoginAlert("success", `تم تحديث طلبك للمراجعة (رقم الطلب: ${existingId}). تم نسخ نص الطلب.`);
                            return true;
                        }
                    }
                }
                const id = pushed.existing?.request_id || "";
                const prefix = duplicateFieldsText(pushed.fields);
                setLoginAlert(
                    "error",
                    existingBranch && existingBranch !== branchKey
                        ? id
                            ? `${prefix}. أنت مسجل/معتمد مسبقًا كمندوب لفرع (${existingBranch}) (رقم الطلب: ${id}). لا يمكن التسجيل بهذه البيانات لفرع آخر.`
                            : `${prefix}. أنت مسجل/معتمد مسبقًا كمندوب لفرع (${existingBranch}). لا يمكن التسجيل بهذه البيانات لفرع آخر.`
                        : id
                            ? `${prefix}. تم اعتمادك مسبقًا (رقم الطلب: ${id}). جرّب الدخول بنفس البيانات، أو استخدم (نسيت الرقم السري) لإرسال طلب جديد برقم سري مختلف.`
                            : `${prefix}. تم اعتمادك مسبقًا. جرّب الدخول بنفس البيانات، أو استخدم (نسيت الرقم السري) لإرسال طلب جديد برقم سري مختلف.`
                );
                return false;
            }
            if (pushed.reason === "not_configured") {
                setLoginAlert("error", "تعذر إرسال طلب الدخول لأن الربط غير مُعد.");
                return false;
            }
            const raw = pushed.error || {};
            const errMsg = String(raw.message || "");
            if (String(raw.code || "") === "23505" || errMsg.toLowerCase().includes("duplicate")) {
                setLoginAlert("error", "البيانات مسجلة مسبقًا. تأكد من المعلومات وأعد التسجيل.");
                return false;
            }
            setLoginAlert("error", "تعذر إرسال طلب الدخول حاليًا.");
            return false;
        }

        async function trySupabaseDelegateLogin(branchKey, phone, email, secret) {
            const sb = getSupabaseClient();
            if (!sb) return { ok: false, reason: "not_configured" };
            const secretHash = await sha256Hex(secret);
            if (!secretHash) return { ok: false, reason: "hash_failed" };
            const { data, error } = await sb.rpc("check_tree_delegate_access", {
                p_branch_key: branchKey,
                p_phone: phone,
                p_email: email,
                p_secret_hash: secretHash
            });
            if (error) {
                const msg = String(error.message || "");
                if (msg.toLowerCase().includes("check_tree_delegate_access")) {
                    return { ok: false, reason: "rpc_missing", error };
                }
                return { ok: false, reason: "error", error };
            }
            if (!data) return { ok: false, reason: "not_found" };
            if (data.allowed === true) return { ok: true, status: "approved", requestId: data.request_id || "" };
            if (data.status === "pending") return { ok: false, reason: "pending", requestId: data.request_id || "" };
            if (data.status === "rejected") return { ok: false, reason: "rejected", requestId: data.request_id || "" };
            if (data.status === "approved") return { ok: false, reason: "wrong_secret", requestId: data.request_id || "" };
            return { ok: false, reason: "not_found" };
        }

        loginBtn.addEventListener("click", async () => {
            const branchKey = branchSelectLogin.value;
            const phone = normalizePhone(phoneInput ? phoneInput.value : "");
            const email = normalizeEmail(emailInput ? emailInput.value : "");
            const secret = String(codeInput ? codeInput.value : "").trim();

            if (!branchKey || !Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) {
                setLoginAlert("error", "يرجى اختيار الفرع قبل المتابعة.");
                return;
            }
            if (!phone || phone.length < 9) {
                setLoginAlert("error", "يرجى إدخال رقم جوال صحيح.");
                return;
            }
            if (!email || !email.includes("@")) {
                setLoginAlert("error", "يرجى إدخال بريد إلكتروني صحيح.");
                return;
            }
            if (!secret || secret.length < 4) {
                setLoginAlert("error", "يرجى إدخال رقم سري (4 أحرف على الأقل).");
                return;
            }

            const sbResult = await trySupabaseDelegateLogin(branchKey, phone, email, secret);
            if (sbResult.ok && sbResult.status === "approved") {
                saveDelegateSession(branchKey, phone, email, secret);
                startBranch(branchKey);
                return;
            }
            if (sbResult.reason === "pending") {
                setLoginAlert("success", `طلبك قيد المراجعة (رقم الطلب: ${sbResult.requestId}).`);
                return;
            }
            if (sbResult.reason === "rejected") {
                setLoginAlert("error", `تم رفض طلبك (رقم الطلب: ${sbResult.requestId}).`);
                return;
            }
            if (sbResult.reason === "wrong_secret") {
                setLoginAlert("error", "الرقم السري غير صحيح لهذا الطلب المعتمد. إذا نسيت الرقم السري اكتب رقمًا سريًا جديدًا ثم اضغط (نسيت الرقم السري) لإرسال طلب اعتماد جديد.");
                return;
            }
            if (sbResult.reason === "rpc_missing") {
                setLoginAlert("error", "يلزم تفعيل دالة التحقق (check_tree_delegate_access) لتعمل الموافقة. سيتم تسجيل طلب جديد.");
            }
            if (sbResult.reason === "error") {
                setLoginAlert("error", "تعذر التحقق من حالة الطلب حاليًا. سيتم تسجيل طلب جديد.");
            }
            if (sbResult.reason === "hash_failed") {
                setLoginAlert("error", "تعذر إنشاء بصمة للرقم السري على هذا الجهاز. سيتم تسجيل طلب جديد.");
            }

            await requestDelegateAccess(branchKey, phone, email, secret);
        });

        if (forgotBtn) {
            forgotBtn.addEventListener("click", async () => {
                const branchKey = branchSelectLogin.value;
                const phone = normalizePhone(phoneInput ? phoneInput.value : "");
                const email = normalizeEmail(emailInput ? emailInput.value : "");
                const secret = String(codeInput ? codeInput.value : "").trim();

                if (!branchKey || !Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) {
                    setLoginAlert("error", "يرجى اختيار الفرع قبل المتابعة.");
                    return;
                }
                if (!phone || phone.length < 9) {
                    setLoginAlert("error", "يرجى إدخال رقم جوال صحيح.");
                    return;
                }
                if (!email || !email.includes("@")) {
                    setLoginAlert("error", "يرجى إدخال بريد إلكتروني صحيح.");
                    return;
                }
                if (!secret || secret.length < 4) {
                    setLoginAlert("error", "اكتب رقمًا سريًا جديدًا (4 أحرف على الأقل) ثم اضغط نسيت الرقم السري لإرسال طلب اعتماد جديد.");
                    return;
                }

                await requestDelegateAccess(branchKey, phone, email, secret, { forceNew: true });
            });
        }

        (async function () {
            const params = new URLSearchParams(window.location.search);
            const branchKey = params.get("branch");
            if (!branchKey) return;
            if (!Object.prototype.hasOwnProperty.call(parentsByBranch, branchKey)) return;
            branchSelectLogin.value = branchKey;
            const phone = normalizePhone(params.get("phone") || "");
            const email = normalizeEmail(params.get("email") || "");
            const secret = String(params.get("code") || "").trim();
            if (phoneInput && phone) phoneInput.value = phone;
            if (emailInput && email) emailInput.value = email;
            if (codeInput && secret) codeInput.value = secret;
        })();

        (async function () {
            if (state.branch) return;
            const existing = loadDelegateSession();
            if (!existing) return;
            if (branchSelectLogin) branchSelectLogin.value = existing.branch;
            if (phoneInput) phoneInput.value = existing.phone;
            if (emailInput) emailInput.value = existing.email;
            if (codeInput) codeInput.value = existing.secret;
            const sbResult = await trySupabaseDelegateLogin(existing.branch, existing.phone, existing.email, existing.secret);
            if (sbResult.ok && sbResult.status === "approved") {
                startBranch(existing.branch);
                return;
            }
            setLoginAlert("error", "تعذر تسجيل الدخول تلقائيًا. اضغط (دخول المندوب) للمتابعة.");
        })();

        logoutBtn.addEventListener("click", () => {
            state.branch = null;
            clearDelegateSession();
            parentSelect.value = "";
            childrenContainer.innerHTML = "";
            hideLoginAlert();
            if (eventsCard) eventsCard.style.display = "none";
            state.happyEvents = [];
            state.sickEvents = [];
            renderHappyEvents();
            renderSickEvents();
            state.deaths = [];
            renderDeaths();
            branchSelectLogin.value = "";
            if (phoneInput) phoneInput.value = "";
            if (emailInput) emailInput.value = "";
            if (codeInput) codeInput.value = "";
            loginCard.style.display = "block";
            dashboardCard.style.display = "none";
        });

        parentSelect.addEventListener("change", () => {
            closeEditChild();
            renderChildrenForParent(parentSelect.value);
        });

        addChildBtn.addEventListener("click", async () => {
            if (!state.branch) {
                setChildAlert("error", "يلزم تسجيل دخول المندوب أولاً.");
                return;
            }
            const selectedParentName = resolveSelectedParentId(normalizePersonName(parentSelect.value), state.branch);
            const rawName = normalizePersonName(childName.value);
            const deceased = !!(childDeceased && childDeceased.checked);
            const hijriInput = deceased ? "" : (childBirthHijri ? String(childBirthHijri.value || "").trim() : "");
            const gregInput = deceased ? "" : (childBirthGreg ? String(childBirthGreg.value || "").trim() : "");
            const hijriNorm = hijriInput ? normalizeHijriDateISO(hijriInput) : "";
            const gregNorm = gregInput ? normalizeGregorianDateISO(gregInput) : "";
            if (hijriInput && !hijriNorm) {
                setChildAlert("error", "تاريخ الميلاد (هجري) غير صحيح. الصيغة: YYYY-MM-DD");
                return;
            }
            if (gregInput && !gregNorm) {
                setChildAlert("error", "تاريخ الميلاد (ميلادي) غير صحيح.");
                return;
            }
            let finalHijri = hijriNorm;
            let finalGreg = gregNorm;
            if (finalHijri && !finalGreg) finalGreg = hijriToGregorianISO(finalHijri);
            if (finalGreg && !finalHijri) finalHijri = gregorianToHijriISO(finalGreg);
            if (finalHijri && !finalGreg) {
                setChildAlert("error", "تعذر تحويل التاريخ الهجري إلى ميلادي.");
                return;
            }
            if (finalGreg && !finalHijri) {
                setChildAlert("error", "تعذر تحويل التاريخ الميلادي إلى هجري.");
                return;
            }
            const birthYear = finalHijri ? normalizeBirthYear(finalHijri.slice(0, 4)) : null;
            const city = deceased ? "" : normalizePersonName(childCity.value);
            const area = deceased ? "" : normalizePersonName(childArea.value);
            if (!rawName) {
                setChildAlert("error", "يرجى إدخال اسم الابن.");
                return;
            }
            const sb = getSupabaseClient();
            if (!sb) {
                setChildAlert("error", "تعذر الحفظ لأن الربط غير مُعد.");
                return;
            }

            const buildChildId = (parentId, baseName) => {
                const p = normalizePersonName(parentId || "");
                const b = normalizePersonName(baseName || "");
                if (!p || !b) return "";
                return p + "/" + b;
            };

            const tokens = tokenizeLineageInput(rawName);
            const lineagePlan = buildLineagePlanFromTokens(tokens, state.branch, selectedParentName);

            const baseNames = getAllBaseNames();
            const nowIso = new Date().toISOString();

            const getSiblingPartsFromRawInput = (input, selectedParentId, plan) => {
                const v = normalizePersonName(input || "");
                if (!v) return [];
                if (!selectedParentId) return [];
                if (plan && plan.anchorParent && Array.isArray(plan.chain) && plan.chain.length) return [];

                const parts = [];
                const pushAll = (arr) => {
                    (Array.isArray(arr) ? arr : []).forEach((p) => {
                        const n = normalizePersonName(p);
                        if (n) parts.push(n);
                    });
                };

                if (/[&,،]/.test(v) || v.includes("\n")) {
                    pushAll(v.split(/[&,،\n]/g));
                } else if (/\s+و\s+/.test(v)) {
                    pushAll(v.split(/\s+و\s+/g));
                } else if (/\s+/.test(v) && !/\b(بن|ابن|بنت)\b/.test(v)) {
                    pushAll(v.split(/\s+/g));
                }

                const uniq = [];
                const seen = new Set();
                parts.forEach((p) => {
                    const key = normalizePersonName(p);
                    if (!key || seen.has(key)) return;
                    seen.add(key);
                    uniq.push(key);
                });
                return uniq;
            };

            const siblingParts = getSiblingPartsFromRawInput(rawName, selectedParentName, lineagePlan);

            if (siblingParts.length > 1) {
                if (!selectedParentName) {
                    setChildAlert("error", "يرجى اختيار الأب أولاً لإضافة عدة أسماء كإخوة.");
                    return;
                }
                const parentName = selectedParentName;
                let inserted = 0;
                let skipped = 0;
                for (let i = 0; i < siblingParts.length; i++) {
                    const part = siblingParts[i];
                    const base = normalizePersonBaseName(part);
                    if (!base) continue;
                    if (normalizePersonBaseName(base) === normalizePersonBaseName(parentName)) {
                        setChildAlert("error", "لا يمكن أن يكون اسم الابن مطابقًا لاسم الأب.");
                        return;
                    }
                    if (findChildNameByBase(parentName, base)) {
                        skipped += 1;
                        continue;
                    }
                    const childId = buildChildId(parentName, base);
                    if (!childId) continue;
                    const row = {
                        branch_key: state.branch,
                        parent_name: parentName,
                        child_name: childId,
                        birth_date_g: finalGreg || null,
                        birth_date_h: finalHijri || null,
                        birth_year: birthYear,
                        city: city || null,
                        area: area || null,
                        is_deceased: deceased,
                        created_at: nowIso
                    };
                    const insertRes = await rpcInsertTreeChildRow(sb, row);
                    if (!insertRes.ok) {
                        const err = insertRes.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            setChildAlert(
                                "error",
                                "لا يمكن الحفظ الآن لأن دوال الشجرة غير مفعلة في Supabase (tree_children_insert_v1 / tree_children_update_v1 / tree_children_delete_v1)."
                            );
                            return;
                        }
                        setChildAlert("error", formatTreeChildrenDbError(err, "save"));
                        return;
                    }
                    if (!state.children[parentName]) state.children[parentName] = [];
                    state.children[parentName].push({
                        name: childId,
                        year: birthYear ? String(birthYear) : "",
                        gdate: finalGreg || "",
                        hdate: finalHijri || "",
                        city: city || "",
                        area: area || "",
                        deceased
                    });
                    baseNames.add(base);
                    inserted += 1;
                }

                childName.value = "";
                if (childBirthHijri) childBirthHijri.value = "";
                if (childBirthGreg) childBirthGreg.value = "";
                childCity.value = "";
                childArea.value = "";
                if (childDeceased) childDeceased.checked = false;
                applyAddDeceasedUiMode();

                const reloadRes = await loadChildrenForBranch(state.branch, { applyToState: true });
                if (!reloadRes.ok) {
                    setChildAlert(
                        "success",
                        "تم حفظ الأسماء في قاعدة البيانات، لكن تعذر تحديث العرض الآن. " + formatTreeChildrenDbError(reloadRes.error, "load")
                    );
                    return;
                }
                renderParentsForBranch(state.branch);
                selectParentForAdding(parentName);
                setChildAlert("success", "تم حفظ الأسماء كإخوة. تمت إضافة: " + String(inserted) + "، وتجاهل المكرر: " + String(skipped));
                renderChildrenForParent(parentName);
                return;
            }

            if (lineagePlan && lineagePlan.anchorParent && lineagePlan.chain && lineagePlan.chain.length) {
                let currentParent = normalizePersonName(lineagePlan.anchorParent);
                let inserted = 0;
                let skipped = 0;
                let youngestFinal = "";

                for (let i = 0; i < lineagePlan.chain.length; i++) {
                    const desiredChild = normalizePersonName(lineagePlan.chain[i]);
                    const desiredBase = normalizePersonBaseName(desiredChild);
                    if (!desiredBase) continue;
                    if (desiredBase === normalizePersonBaseName(currentParent)) {
                        setChildAlert("error", "لا يمكن أن يكون اسم الابن مطابقًا لاسم الأب.");
                        return;
                    }

                    const isYoungest = i === lineagePlan.chain.length - 1;
                    const finalChild = normalizePersonBaseName(desiredChild);
                    const tokensCheck = tokenizeLineageInput(finalChild);
                    if (isYoungest && tokensCheck.length !== 1) {
                        setChildAlert("error", "ممنوع تسجيل الاسم الأخير بأكثر من كلمة. اكتب اسم الابن فقط.");
                        return;
                    }
                    const finalChildBase = normalizePersonBaseName(finalChild);
                    if (!finalChild || !finalChildBase) continue;

                    const existingChildName = findChildNameByBase(currentParent, finalChildBase);
                    if (existingChildName) {
                        skipped += 1;
                        currentParent = existingChildName;
                        youngestFinal = existingChildName;
                        continue;
                    }

                    const childId = buildChildId(currentParent, finalChildBase);
                    if (!childId) continue;

                    const row = {
                        branch_key: state.branch,
                        parent_name: currentParent,
                        child_name: childId,
                        birth_date_g: isYoungest ? (finalGreg || null) : null,
                        birth_date_h: isYoungest ? (finalHijri || null) : null,
                        birth_year: isYoungest ? birthYear : null,
                        city: isYoungest ? (city || null) : null,
                        area: isYoungest ? (area || null) : null,
                        is_deceased: isYoungest ? deceased : null,
                        created_at: nowIso
                    };
                    const insertRes = await rpcInsertTreeChildRow(sb, row);
                    if (!insertRes.ok) {
                        const err = insertRes.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            setChildAlert(
                                "error",
                                "لا يمكن الحفظ الآن لأن دوال الشجرة غير مفعلة في Supabase (tree_children_insert_v1 / tree_children_update_v1 / tree_children_delete_v1)."
                            );
                            return;
                        }
                        setChildAlert("error", formatTreeChildrenDbError(err, "save"));
                        return;
                    }

                    if (!state.children[currentParent]) state.children[currentParent] = [];
                    state.children[currentParent].push({
                        name: childId,
                        year: isYoungest && birthYear ? String(birthYear) : "",
                        gdate: isYoungest ? (finalGreg || "") : "",
                        hdate: isYoungest ? (finalHijri || "") : "",
                        city: isYoungest ? (city || "") : "",
                        area: isYoungest ? (area || "") : "",
                        deceased: isYoungest ? deceased : false
                    });

                    baseNames.add(normalizePersonBaseName(finalChild));
                    inserted += 1;
                    currentParent = childId;
                    youngestFinal = childId;
                }

                childName.value = "";
                if (childBirthHijri) childBirthHijri.value = "";
                if (childBirthGreg) childBirthGreg.value = "";
                childCity.value = "";
                childArea.value = "";
                if (childDeceased) childDeceased.checked = false;

                const reloadRes = await loadChildrenForBranch(state.branch, { applyToState: true });
                if (!reloadRes.ok) {
                    setChildAlert(
                        "success",
                        "تم حفظ السلسلة في قاعدة البيانات، لكن تعذر تحديث العرض الآن. " + formatTreeChildrenDbError(reloadRes.error, "load")
                    );
                    return;
                }
                renderParentsForBranch(state.branch);
                if (youngestFinal) selectParentForAdding(youngestFinal);

                setChildAlert(
                    "success",
                    "تم حفظ السلسلة. تمت إضافة: " + String(inserted) + "، وتجاهل المكرر: " + String(skipped)
                );
                if (!youngestFinal) {
                    if (selectedParentName) renderChildrenForParent(selectedParentName);
                    else renderChildrenForParent(lineagePlan.anchorParent);
                }
                return;
            }

            if (!selectedParentName) {
                setChildAlert("error", "يرجى اختيار الأب أولاً أو اكتب الاسم كسلسلة تنتهي باسم الفرع.");
                return;
            }

            const parentName = selectedParentName;
            if (normalizePersonBaseName(rawName) === normalizePersonBaseName(parentName)) {
                setChildAlert("error", "لا يمكن أن يكون اسم الابن مطابقًا لاسم الأب.");
                return;
            }

            const tokensCheck = tokenizeLineageInput(rawName);
            if (tokensCheck.length !== 1) {
                setChildAlert("error", "ممنوع تسجيل الاسم الأخير بأكثر من كلمة. اكتب اسم الابن فقط.");
                return;
            }
            const inputBase = normalizePersonBaseName(rawName);
            if (findChildNameByBase(parentName, inputBase)) {
                setChildAlert("error", "اسم الابن مسجل مسبقًا لهذا الأب.");
                return;
            }

            const finalName = normalizePersonBaseName(rawName);

            if (normalizePersonBaseName(finalName) === normalizePersonBaseName(parentName)) {
                setChildAlert("error", "لا يمكن أن يكون اسم الابن مطابقًا لاسم الأب.");
                return;
            }

            const childId = buildChildId(parentName, finalName);
            if (!childId) {
                setChildAlert("error", "تعذر حفظ الاسم بسبب خطأ في بناء المعرف.");
                return;
            }

            const row = {
                branch_key: state.branch,
                parent_name: parentName,
                child_name: childId,
                birth_date_g: finalGreg || null,
                birth_date_h: finalHijri || null,
                birth_year: birthYear,
                city: city || null,
                area: area || null,
                is_deceased: deceased,
                created_at: nowIso
            };
            const insertRes = await rpcInsertTreeChildRow(sb, row);
            if (!insertRes.ok) {
                const err = insertRes.error || { message: "unknown error" };
                if (isRpcMissingError(err)) {
                    setChildAlert(
                        "error",
                        "لا يمكن الحفظ الآن لأن دوال الشجرة غير مفعلة في Supabase (tree_children_insert_v1 / tree_children_update_v1 / tree_children_delete_v1)."
                    );
                    return;
                }
                setChildAlert("error", formatTreeChildrenDbError(insertRes.error, "save"));
                return;
            }

            childName.value = "";
            if (childBirthHijri) childBirthHijri.value = "";
            if (childBirthGreg) childBirthGreg.value = "";
            childCity.value = "";
            childArea.value = "";
            if (childDeceased) childDeceased.checked = false;
            applyAddDeceasedUiMode();
            const reloadRes = await loadChildrenForBranch(state.branch, { applyToState: true });
            if (!reloadRes.ok) {
                setChildAlert(
                    "success",
                    "تم حفظ بيانات الابن في قاعدة البيانات، لكن تعذر تحديث العرض الآن. " + formatTreeChildrenDbError(reloadRes.error, "load")
                );
                return;
            }
            renderParentsForBranch(state.branch);
            selectParentForAdding(childId);
            setChildAlert("success", "تم حفظ بيانات الابن في قاعدة البيانات: " + finalName);
        });

        function syncEditBirthFromHijri() {
            if (isSyncingBirthDates) return;
            if (!editChildHijri || !editChildGreg) return;
            const hijriValue = String(editChildHijri.value || "").trim();
            if (!hijriValue) return;
            const hijriISO = normalizeHijriDateISO(hijriValue);
            if (!hijriISO) return;
            const gregISO = hijriToGregorianISO(hijriISO);
            if (!gregISO) return;
            isSyncingBirthDates = true;
            editChildHijri.value = hijriISO;
            editChildGreg.value = gregISO;
            isSyncingBirthDates = false;
        }

        function syncEditBirthFromGreg() {
            if (isSyncingBirthDates) return;
            if (!editChildHijri || !editChildGreg) return;
            const gregISO = normalizeGregorianDateISO(String(editChildGreg.value || "").trim());
            if (!gregISO) return;
            const hijriISO = gregorianToHijriISO(gregISO);
            if (!hijriISO) return;
            isSyncingBirthDates = true;
            editChildGreg.value = gregISO;
            editChildHijri.value = hijriISO;
            isSyncingBirthDates = false;
        }

        if (editChildHijri) {
            editChildHijri.addEventListener("input", () => {
                syncEditBirthFromHijri();
            });
            editChildHijri.addEventListener("blur", () => {
                syncEditBirthFromHijri();
            });
        }
        if (editChildGreg) {
            editChildGreg.addEventListener("change", () => {
                syncEditBirthFromGreg();
            });
        }

        if (childDeceased) {
            childDeceased.addEventListener("change", () => {
                applyAddDeceasedUiMode();
            });
            applyAddDeceasedUiMode();
        }
        if (editChildDeceased) {
            editChildDeceased.addEventListener("change", () => {
                applyEditDeceasedUiMode();
            });
        }

        if (cancelEditBtn) {
            cancelEditBtn.addEventListener("click", () => {
                closeEditChild();
            });
        }

        if (saveEditBtn) {
            saveEditBtn.addEventListener("click", async () => {
                if (!editingChildRef || !editingChildRef.childId || !editingChildRef.parentId) return;
                if (!state.branch) {
                    setEditChildAlert("error", "يلزم تسجيل دخول المندوب أولاً.");
                    return;
                }
                const deceased = !!(editChildDeceased && editChildDeceased.checked);
                const hijriInput = deceased ? "" : (editChildHijri ? String(editChildHijri.value || "").trim() : "");
                const gregInput = deceased ? "" : (editChildGreg ? String(editChildGreg.value || "").trim() : "");
                const hijriNorm = hijriInput ? normalizeHijriDateISO(hijriInput) : "";
                const gregNorm = gregInput ? normalizeGregorianDateISO(gregInput) : "";
                if (hijriInput && !hijriNorm) {
                    setEditChildAlert("error", "تاريخ الميلاد (هجري) غير صحيح. الصيغة: YYYY-MM-DD");
                    return;
                }
                if (gregInput && !gregNorm) {
                    setEditChildAlert("error", "تاريخ الميلاد (ميلادي) غير صحيح.");
                    return;
                }
                let finalHijri = hijriNorm;
                let finalGreg = gregNorm;
                if (finalHijri && !finalGreg) finalGreg = hijriToGregorianISO(finalHijri);
                if (finalGreg && !finalHijri) finalHijri = gregorianToHijriISO(finalGreg);
                if (finalHijri && !finalGreg) {
                    setEditChildAlert("error", "تعذر تحويل التاريخ الهجري إلى ميلادي.");
                    return;
                }
                if (finalGreg && !finalHijri) {
                    setEditChildAlert("error", "تعذر تحويل التاريخ الميلادي إلى هجري.");
                    return;
                }
                const birthYear = finalHijri ? normalizeBirthYear(finalHijri.slice(0, 4)) : null;
                const city = deceased ? "" : (editChildCity ? normalizePersonName(editChildCity.value) : "");
                const area = deceased ? "" : (editChildArea ? normalizePersonName(editChildArea.value) : "");
                const sb = getSupabaseClient();
                if (!sb) {
                    setEditChildAlert("error", "تعذر الحفظ لأن الربط غير مُعد.");
                    return;
                }

                const patch = {
                    birth_date_g: finalGreg || null,
                    birth_date_h: finalHijri || null,
                    birth_year: birthYear,
                    city: city || null,
                    area: area || null,
                    is_deceased: deceased
                };

                const res = await rpcUpdateTreeChildRow(sb, state.branch, editingChildRef.parentId, editingChildRef.childId, patch);
                if (!res.ok) {
                    const err = res.error || { message: "unknown error" };
                    if (isRpcMissingError(err)) {
                        setEditChildAlert(
                            "error",
                            "لا يمكن تنفيذ التعديل الآن لأن دوال الشجرة غير مفعلة في Supabase (tree_children_insert_v1 / tree_children_update_v1 / tree_children_delete_v1)."
                        );
                        return;
                    }
                    setEditChildAlert("error", formatTreeChildrenDbError(err, "update"));
                    return;
                }

                const applyPatchToState = () => {
                    const parentId = normalizePersonName(editingChildRef.parentId);
                    const childId = normalizePersonName(editingChildRef.childId);
                    if (!parentId || !childId) return false;

                    const updateChild = (p) => {
                        const key = normalizePersonName(p);
                        if (!key) return false;
                        const list = state.children[key];
                        if (!Array.isArray(list) || !list.length) return false;
                        const idx = list.findIndex((c) => normalizePersonName(c && c.name ? c.name : "") === childId);
                        if (idx < 0) return false;
                        const prev = list[idx] || {};
                        list[idx] = {
                            ...prev,
                            year: birthYear ? String(birthYear) : "",
                            gdate: finalGreg || "",
                            hdate: finalHijri || "",
                            city: city || "",
                            area: area || "",
                            deceased
                        };
                        return true;
                    };

                    if (updateChild(parentId)) return true;
                    const parents = Object.keys(state.children || {});
                    for (let i = 0; i < parents.length; i++) {
                        if (updateChild(parents[i])) return true;
                    }
                    return false;
                };
                applyPatchToState();

                const reloadRes = await loadChildrenForBranch(state.branch, { applyToState: true });
                if (!reloadRes.ok) {
                    renderParentsForBranch(state.branch);
                    ensureParentOption(editingChildRef.parentId);
                    parentSelect.value = editingChildRef.parentId;
                    renderChildrenForParent(editingChildRef.parentId);
                    closeEditChild();
                    setChildAlert(
                        "success",
                        "تم حفظ التعديل. تعذر تحديث البيانات من قاعدة البيانات الآن، لكن تم تحديث العرض محلياً."
                    );
                    return;
                }

                renderParentsForBranch(state.branch);
                ensureParentOption(editingChildRef.parentId);
                parentSelect.value = editingChildRef.parentId;
                renderChildrenForParent(editingChildRef.parentId);
                closeEditChild();
                setChildAlert(
                    "success",
                    res.degraded
                        ? "تم حفظ التعديل، لكن تعذر حفظ حالة متوفى في Supabase لأن عمود الوفاة غير متاح."
                        : "تم حفظ التعديل."
                );
            });
        }

        const EVENTS_REFRESH_KEY = "alzidan_events_refresh_v1";
        function touchEventsRefresh() {
            try {
                localStorage.setItem(EVENTS_REFRESH_KEY, String(Date.now()));
            } catch (e) {}
        }

        function resetHappyForm() {
            editingHappy = null;
            if (happyType) happyType.value = "";
            if (happyPerson) happyPerson.value = "";
            if (happyDate) happyDate.value = todayGregorianISO();
            if (happyVisibilityDays) happyVisibilityDays.value = "7";
            if (happyDetails) happyDetails.value = "";
            if (saveHappyBtn) saveHappyBtn.textContent = "إضافة";
            if (cancelHappyBtn) cancelHappyBtn.style.display = "none";
        }

        function resetSickForm() {
            editingSick = null;
            if (sickType) sickType.value = "";
            if (sickPerson) sickPerson.value = "";
            if (sickDate) sickDate.value = todayGregorianISO();
            if (sickVisibilityDays) sickVisibilityDays.value = "7";
            if (sickPlace) sickPlace.value = "hospital";
            if (sickHospitalName) sickHospitalName.value = "";
            if (sickHospitalDept) sickHospitalDept.value = "";
            if (sickHomeCity) sickHomeCity.value = "";
            if (sickHomeArea) sickHomeArea.value = "";
            if (sickContactMethod) sickContactMethod.value = "visit";
            if (sickVisitDateFrom) sickVisitDateFrom.value = "";
            if (sickVisitDateTo) sickVisitDateTo.value = "";
            if (sickVisitTimeFrom) sickVisitTimeFrom.value = "";
            if (sickVisitTimeTo) sickVisitTimeTo.value = "";
            if (sickVisitTimeFromHour) sickVisitTimeFromHour.value = "";
            if (sickVisitTimeFromMinute) sickVisitTimeFromMinute.value = "";
            if (sickVisitTimeFromPeriod) sickVisitTimeFromPeriod.value = "";
            if (sickVisitTimeToHour) sickVisitTimeToHour.value = "";
            if (sickVisitTimeToMinute) sickVisitTimeToMinute.value = "";
            if (sickVisitTimeToPeriod) sickVisitTimeToPeriod.value = "";
            if (sickContactPhone) sickContactPhone.value = "";
            if (sickNotes) sickNotes.value = "";
            if (saveSickBtn) saveSickBtn.textContent = "إضافة";
            if (cancelSickBtn) cancelSickBtn.style.display = "none";
            updateSickPlaceVisibility();
            updateSickContactModeVisibility();
        }

        function resetDeathForm() {
            editingDeath = null;
            if (deathPerson) deathPerson.value = "";
            if (deathDate) deathDate.value = todayGregorianISO();
            if (deathVisibilityDays) deathVisibilityDays.value = "7";
            if (prayerPlace) prayerPlace.value = "";
            if (prayerTime) prayerTime.value = "";
            if (burialPlace) burialPlace.value = "";
            if (burialTime) burialTime.value = "";
            if (condolencePlace) condolencePlace.value = "";
            if (condolenceTime) condolenceTime.value = "";
            if (condolencePhone1) condolencePhone1.value = "";
            if (condolencePhone2) condolencePhone2.value = "";
            if (deathNotes) deathNotes.value = "";
            if (saveDeathBtn) saveDeathBtn.textContent = "نشر";
            if (cancelDeathBtn) cancelDeathBtn.style.display = "none";
        }

        function resolveEventDateInputValue(row) {
            const raw = row && row.event_date != null ? String(row.event_date).trim() : "";
            const iso = /^(\d{4})-(\d{1,2})-(\d{1,2})/.exec(raw);
            if (iso) {
                const y = iso[1].padStart(4, "0");
                const m = iso[2].padStart(2, "0");
                const d = iso[3].padStart(2, "0");
                return y + "-" + m + "-" + d;
            }
            const labelRaw = row && row.date_label != null ? String(row.date_label).trim() : "";
            let s = labelRaw;
            for (let i = 0; i < 3; i++) {
                const m = /^\s*[\(（]\s*(.*?)\s*[\)）]\s*$/.exec(s);
                if (!m) break;
                s = String(m[1] || "").trim();
                if (!s) break;
            }
            const labelIso = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s);
            if (labelIso) {
                const y = labelIso[1].padStart(4, "0");
                const m = labelIso[2].padStart(2, "0");
                const d = labelIso[3].padStart(2, "0");
                const year = parseInt(y, 10);
                if (year >= 1200 && year <= 1700) {
                    const g = hijriToGregorianISO(y + "-" + m + "-" + d);
                    if (g) return g;
                }
                if (year >= 1900 && year <= 2100) return y + "-" + m + "-" + d;
            }
            const slash = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
            if (slash) {
                const d = slash[1].padStart(2, "0");
                const m = slash[2].padStart(2, "0");
                const y = slash[3];
                const year = parseInt(y, 10);
                if (year >= 1200 && year <= 1700) {
                    const g = hijriToGregorianISO(y + "-" + m + "-" + d);
                    if (g) return g;
                }
                if (year >= 1900 && year <= 2100) return y + "-" + m + "-" + d;
            }
            return todayGregorianISO();
        }

        function startEditHappy(row) {
            editingHappy = row || null;
            if (happySection) happySection.open = true;
            if (happyType) happyType.value = String(row && row.type ? row.type : "");
            if (happyPerson) happyPerson.value = normalizePersonName(row && row.person ? row.person : "");
            if (happyDate) happyDate.value = resolveEventDateInputValue(row || {});
            if (happyVisibilityDays) happyVisibilityDays.value = String(getEventVisibilityDays(row || {}));
            if (happyDetails) happyDetails.value = getHappyDetailsText(row || {});
            if (saveHappyBtn) saveHappyBtn.textContent = "حفظ التعديل";
            if (cancelHappyBtn) cancelHappyBtn.style.display = "inline-flex";
        }

        function startEditSick(row) {
            editingSick = row || null;
            if (sickSection) sickSection.open = true;
            if (sickType) sickType.value = String(row && row.type ? row.type : "");
            if (sickPerson) sickPerson.value = normalizePersonName(row && row.person ? row.person : "");
            if (sickDate) sickDate.value = resolveEventDateInputValue(row || {});
            if (sickVisibilityDays) sickVisibilityDays.value = String(getEventVisibilityDays(row || {}));

            const health = parseHealthDetails(row || {});
            if (sickPlace) sickPlace.value = health.place === "home" ? "home" : "hospital";
            if (sickHomeCity) sickHomeCity.value = health.homeCity || "";
            if (sickHomeArea) sickHomeArea.value = health.homeArea || "";
            if (sickNotes) sickNotes.value = health.notes || "";

            const hospitalNameValue = String(row && (row.hospital_name || row.hospitalName) ? (row.hospital_name || row.hospitalName) : health.hospitalName || "").trim();
            const hospitalDeptValue = String(row && (row.hospital_dept || row.hospitalDept) ? (row.hospital_dept || row.hospitalDept) : health.hospitalDept || "").trim();
            if (sickHospitalName) sickHospitalName.value = hospitalNameValue;
            if (sickHospitalDept) sickHospitalDept.value = hospitalDeptValue;

            if (sickContactMethod) sickContactMethod.value = String(row && row.contact_method ? row.contact_method : "visit");
            if (sickContactPhone) sickContactPhone.value = String(row && row.contact_phone ? row.contact_phone : "");
            if (sickVisitDateFrom) sickVisitDateFrom.value = String(row && row.visit_date_from ? row.visit_date_from : "");
            if (sickVisitDateTo) sickVisitDateTo.value = String(row && row.visit_date_to ? row.visit_date_to : "");
            if (sickVisitTimeFrom) sickVisitTimeFrom.value = String(row && row.visit_time_from ? row.visit_time_from : "");
            if (sickVisitTimeTo) sickVisitTimeTo.value = String(row && row.visit_time_to ? row.visit_time_to : "");
            setVisitTimeSelectorsFromValue(sickVisitTimeFromHour, sickVisitTimeFromMinute, sickVisitTimeFromPeriod, sickVisitTimeFrom && sickVisitTimeFrom.value ? sickVisitTimeFrom.value : "");
            setVisitTimeSelectorsFromValue(sickVisitTimeToHour, sickVisitTimeToMinute, sickVisitTimeToPeriod, sickVisitTimeTo && sickVisitTimeTo.value ? sickVisitTimeTo.value : "");

            updateSickPlaceVisibility();
            updateSickContactModeVisibility();
            if (saveSickBtn) saveSickBtn.textContent = "حفظ التعديل";
            if (cancelSickBtn) cancelSickBtn.style.display = "inline-flex";
        }

        function startEditDeath(row) {
            editingDeath = row || null;
            if (deathSection) deathSection.open = true;
            if (deathPerson) deathPerson.value = normalizePersonName(row && row.person ? row.person : "");
            if (deathDate) deathDate.value = resolveEventDateInputValue(row || {});
            if (deathVisibilityDays) deathVisibilityDays.value = String(getEventVisibilityDays(row || {}));
            const d = parseDeathDetails(row || {});
            if (prayerPlace) prayerPlace.value = d.prayerPlace || "";
            if (prayerTime) prayerTime.value = d.prayerTime || "";
            if (burialPlace) burialPlace.value = d.burialPlace || "";
            if (burialTime) burialTime.value = d.burialTime || "";
            if (condolencePlace) condolencePlace.value = d.condolencePlace || "";
            if (condolenceTime) condolenceTime.value = d.condolenceTime || "";
            if (condolencePhone1) condolencePhone1.value = d.phones && d.phones[0] ? d.phones[0] : "";
            if (condolencePhone2) condolencePhone2.value = d.phones && d.phones[1] ? d.phones[1] : "";
            if (deathNotes) deathNotes.value = d.notes || "";
            if (saveDeathBtn) saveDeathBtn.textContent = "حفظ التعديل";
            if (cancelDeathBtn) cancelDeathBtn.style.display = "inline-flex";
        }

        async function deleteEventRow(row, opts) {
            const options = opts || {};
            const pk = getEventPk(row);
            if (!pk) return;
            const personName = normalizePersonName(row && row.person ? row.person : "");
            const confirmName = personName || "حذف";
            const ok = await confirmTypedText(confirmName, {
                title: "تأكيد حذف الخبر",
                body: "لتأكيد الحذف اكتب الاسم التالي بالضبط:",
                confirmLabel: "تأكيد الحذف",
                cancelLabel: "إلغاء"
            });
            if (!ok) return;
            const sb = getSupabaseClient();
            const alertEl = options.kind === "death" ? deathAlert : options.kind === "sick" ? sickAlert : happyAlert;
            if (!sb) {
                showAlertAndFocus(alertEl, "error", "تعذر الحذف لأن الربط غير مُعد.");
                return;
            }
            const res = await rpcDeleteFamilyEventRow(sb, pk);
            if (!res.ok) {
                const err = res.error || { message: "unknown error" };
                if (isRpcMissingError(err)) {
                    showAlertAndFocus(
                        alertEl,
                        "error",
                        "لا يمكن الحذف الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                    );
                    return;
                }
                const msg = String(err && err.message ? err.message : "");
                if (msg.toLowerCase().includes("not allowed")) {
                    showAlertAndFocus(alertEl, "error", "لا توجد صلاحية لتعديل/حذف المناسبات لهذا المندوب.");
                    return;
                }
                showAlertAndFocus(alertEl, "error", "تعذر الحذف: " + (msg || "خطأ غير معروف"));
                return;
            }
            touchEventsRefresh();
            if (options.kind === "death") {
                showAlertAndFocus(deathAlert, "success", "تم الحذف.");
                await loadDeathsForBranch(state.branch);
                return;
            }
            showAlertAndFocus(alertEl, "success", "تم الحذف.");
            await loadEventsForBranch(state.branch);
        }

        function isPermissionDeniedError(err) {
            const msgRaw = err && err.message != null ? String(err.message) : "";
            const detailsRaw = err && err.details != null ? String(err.details) : "";
            const codeRaw = err && err.code != null ? String(err.code) : "";
            const low = (codeRaw + " " + msgRaw + " " + detailsRaw).toLowerCase();
            return (
                low.includes("row-level security") ||
                low.includes("violates row-level security") ||
                low.includes("permission denied") ||
                low.includes("not authorized") ||
                low.includes("not allowed") ||
                low.includes("42501")
            );
        }

        if (cancelHappyBtn) cancelHappyBtn.addEventListener("click", () => resetHappyForm());
        if (cancelSickBtn) cancelSickBtn.addEventListener("click", () => resetSickForm());
        if (cancelDeathBtn) cancelDeathBtn.addEventListener("click", () => resetDeathForm());

        if (sickPlace) sickPlace.addEventListener("change", updateSickPlaceVisibility);
        if (sickContactMethod) sickContactMethod.addEventListener("change", updateSickContactModeVisibility);
        if (sickVisitTimeFromHour) sickVisitTimeFromHour.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeFromHour, sickVisitTimeFromMinute, sickVisitTimeFromPeriod, sickVisitTimeFrom));
        if (sickVisitTimeFromMinute) sickVisitTimeFromMinute.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeFromHour, sickVisitTimeFromMinute, sickVisitTimeFromPeriod, sickVisitTimeFrom));
        if (sickVisitTimeFromPeriod) sickVisitTimeFromPeriod.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeFromHour, sickVisitTimeFromMinute, sickVisitTimeFromPeriod, sickVisitTimeFrom));
        if (sickVisitTimeToHour) sickVisitTimeToHour.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeToHour, sickVisitTimeToMinute, sickVisitTimeToPeriod, sickVisitTimeTo));
        if (sickVisitTimeToMinute) sickVisitTimeToMinute.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeToHour, sickVisitTimeToMinute, sickVisitTimeToPeriod, sickVisitTimeTo));
        if (sickVisitTimeToPeriod) sickVisitTimeToPeriod.addEventListener("change", () => syncVisitTimeHidden(sickVisitTimeToHour, sickVisitTimeToMinute, sickVisitTimeToPeriod, sickVisitTimeTo));

        if (saveHappyBtn) {
            saveHappyBtn.addEventListener("click", async () => {
                if (!state.branch) {
                    showAlert(happyAlert, "error", "يلزم تسجيل دخول المندوب أولاً.");
                    return;
                }
                const type = String(happyType && happyType.value ? happyType.value : "").trim();
                const person = normalizePersonName(happyPerson && happyPerson.value ? happyPerson.value : "");
                let dateValue = String(happyDate && happyDate.value ? happyDate.value : "").trim();
                const detailsText = String(happyDetails && happyDetails.value ? happyDetails.value : "").trim();
                if (!type || !person) {
                    showAlert(happyAlert, "error", "يرجى اختيار نوع المناسبة وكتابة اسم الشخص.");
                    return;
                }
                if (!dateValue) {
                    dateValue = todayGregorianISO();
                    if (happyDate) happyDate.value = dateValue;
                }
                const dateLabel = dateValue ? formatDateISO(dateValue) : "";
                const sb = getSupabaseClient();
                if (!sb) {
                    showAlert(happyAlert, "error", "تعذر الحفظ لأن الربط غير مُعد.");
                    return;
                }
                const looksLikeMessage =
                    detailsText &&
                    (detailsText.split(/\s+/).filter(Boolean).length >= 4 ||
                        detailsText.includes("مبروك") ||
                        detailsText.includes("نبارك") ||
                        detailsText.includes("تهانينا"));
                const baseHappyText = formatEventText({ type, person });
                const storedText = looksLikeMessage ? detailsText : baseHappyText;
                const showDays = clampVisibilityDays(happyVisibilityDays && happyVisibilityDays.value ? happyVisibilityDays.value : 7);
                const happyPayload = {
                    v: 1,
                    kind: "happy_notice",
                    text: storedText || "",
                    extra: looksLikeMessage ? "" : detailsText,
                    showDays
                };
                const patch = {
                    branch_key: state.branch,
                    type,
                    person,
                    date_label: dateLabel || null,
                    event_date: dateValue || null,
                    details: JSON.stringify(happyPayload),
                    hospital_name: null,
                    hospital_dept: null,
                    contact_method: null,
                    contact_phone: null,
                    visit_date_from: null,
                    visit_date_to: null,
                    visit_time_from: null,
                    visit_time_to: null
                };

                if (editingHappy) {
                    const pk = getEventPk(editingHappy);
                    if (!pk) {
                        showAlert(happyAlert, "error", "تعذر حفظ التعديل لأن معرف السجل غير متوفر.");
                        return;
                    }
                    const res = await rpcUpdateFamilyEventRow(sb, pk, patch);
                    if (!res.ok) {
                        const err = res.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            showAlert(
                                happyAlert,
                                "error",
                                "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                            );
                            return;
                        }
                        if (isCaseTypesTextAndDateMismatchError(err)) {
                            showAlert(
                                happyAlert,
                                "error",
                                "تعذر حفظ التعديل بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                            );
                            return;
                        }
                        const msg = String(err && err.message ? err.message : "");
                        if (msg.toLowerCase().includes("not allowed")) {
                            showAlert(happyAlert, "error", "لا توجد صلاحية لتعديل المناسبات لهذا المندوب.");
                            return;
                        }
                        showAlert(happyAlert, "error", "تعذر حفظ التعديل: " + (msg || "خطأ غير معروف"));
                        return;
                    }
                    touchEventsRefresh();
                    resetHappyForm();
                    showAlert(happyAlert, "success", "تم حفظ التعديل.");
                    await loadEventsForBranch(state.branch);
                    return;
                }

                const row = { ...patch, created_at: new Date().toISOString() };
                const res = await rpcInsertFamilyEventRow(sb, row);
                if (!res.ok) {
                    const err = res.error || { message: "unknown error" };
                    if (isRpcMissingError(err)) {
                        showAlert(
                            happyAlert,
                            "error",
                            "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                        );
                        return;
                    }
                    if (isCaseTypesTextAndDateMismatchError(err)) {
                        showAlert(
                            happyAlert,
                            "error",
                            "تعذر الإضافة بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                        );
                        return;
                    }
                    const msg = String(err && err.message ? err.message : "");
                    if (msg.toLowerCase().includes("not allowed")) {
                        if (err && err.detail === "events_access") {
                            const st = String(err.status || "");
                            const rid = String(err.requestId || "");
                            if (st === "pending") {
                                showAlert(happyAlert, "error", rid ? `صلاحية المناسبات قيد المراجعة (رقم الطلب: ${rid}).` : "صلاحية المناسبات قيد المراجعة.");
                                return;
                            }
                            if (st === "rejected") {
                                showAlert(happyAlert, "error", rid ? `تم رفض صلاحية المناسبات (رقم الطلب: ${rid}).` : "تم رفض صلاحية المناسبات.");
                                return;
                            }
                            if (st === "approved") {
                                showAlert(happyAlert, "error", "الصلاحية معتمدة لكن بيانات الدخول لا تطابق بيانات الاعتماد. جرّب تسجيل خروج/دخول وتأكد من البريد والجوال.");
                                return;
                            }
                        }
                        showAlert(happyAlert, "error", "لا توجد صلاحية لإضافة المناسبات لهذا المندوب.");
                        return;
                    }
                    showAlert(happyAlert, "error", "تعذر الإضافة: " + (msg || "خطأ غير معروف"));
                    return;
                }
                maybeOpenEmailDraft(
                    "مناسبة جديدة (" + type + ")",
                    ["مناسبة جديدة", "الفرع: " + state.branch, "النوع: " + type, "الاسم: " + person, dateLabel ? "التاريخ: " + dateLabel : "", storedText ? "النص: " + storedText : ""]
                        .filter(Boolean)
                        .join("\n")
                );
                touchEventsRefresh();
                resetHappyForm();
                showAlert(happyAlert, "success", "تمت الإضافة.");
                await loadEventsForBranch(state.branch);
            });
        }

        if (saveSickBtn) {
            saveSickBtn.addEventListener("click", async () => {
                if (!state.branch) {
                    showAlert(sickAlert, "error", "يلزم تسجيل دخول المندوب أولاً.");
                    return;
                }
                const type = String(sickType && sickType.value ? sickType.value : "").trim();
                const person = normalizePersonName(sickPerson && sickPerson.value ? sickPerson.value : "");
                let dateValue = String(sickDate && sickDate.value ? sickDate.value : "").trim();
                if (!type || !person) {
                    showAlert(sickAlert, "error", "يرجى اختيار نوع الحالة وكتابة اسم الشخص.");
                    return;
                }
                if (!dateValue) {
                    dateValue = todayGregorianISO();
                    if (sickDate) sickDate.value = dateValue;
                }
                const dateLabel = dateValue ? formatDateISO(dateValue) : "";
                const place = sickPlace && sickPlace.value === "home" ? "home" : "hospital";
                const hospitalNameValue = place === "hospital" ? String(sickHospitalName && sickHospitalName.value ? sickHospitalName.value : "").trim() : "";
                const hospitalDeptValue = place === "hospital" ? String(sickHospitalDept && sickHospitalDept.value ? sickHospitalDept.value : "").trim() : "";
                const homeCityValue = place === "home" ? normalizePersonName(sickHomeCity && sickHomeCity.value ? sickHomeCity.value : "") : "";
                const homeAreaValue = place === "home" ? normalizePersonName(sickHomeArea && sickHomeArea.value ? sickHomeArea.value : "") : "";
                const notesValue = String(sickNotes && sickNotes.value ? sickNotes.value : "").trim();

                const contactMethodValue = String(sickContactMethod && sickContactMethod.value ? sickContactMethod.value : "visit").trim() || "visit";
                const contactPhoneValue = String(sickContactPhone && sickContactPhone.value ? sickContactPhone.value : "").trim();
                const visitDateFromLabel = String(sickVisitDateFrom && sickVisitDateFrom.value ? sickVisitDateFrom.value : "").trim();
                const visitDateToLabel = String(sickVisitDateTo && sickVisitDateTo.value ? sickVisitDateTo.value : "").trim();
                const visitTimeFromValue = String(sickVisitTimeFrom && sickVisitTimeFrom.value ? sickVisitTimeFrom.value : "").trim();
                const visitTimeToValue = String(sickVisitTimeTo && sickVisitTimeTo.value ? sickVisitTimeTo.value : "").trim();

                if (contactMethodValue === "visit") {
                    if (!visitTimeFromValue || !visitTimeToValue) {
                        showAlert(sickAlert, "error", "يرجى تحديد مواعيد الزيارة (من الساعة وإلى الساعة) أو اختر اتصال/واتساب.");
                        return;
                    }
                } else {
                    if (!contactPhoneValue) {
                        showAlert(sickAlert, "error", "يرجى إدخال رقم الجوال للتواصل (اتصال/واتساب).");
                        return;
                    }
                }

                const showDays = clampVisibilityDays(sickVisibilityDays && sickVisibilityDays.value ? sickVisibilityDays.value : 7);
                const payload = {
                    v: 1,
                    kind: "health_notice",
                    place,
                    homeCity: homeCityValue,
                    homeArea: homeAreaValue,
                    notes: notesValue,
                    hospitalName: hospitalNameValue,
                    hospitalDept: hospitalDeptValue,
                    showDays
                };
                const details = JSON.stringify(payload);

                const sb = getSupabaseClient();
                if (!sb) {
                    showAlert(sickAlert, "error", "تعذر الحفظ لأن الربط غير مُعد.");
                    return;
                }

                const patch = {
                    branch_key: state.branch,
                    type,
                    person,
                    date_label: dateLabel || null,
                    event_date: dateValue || null,
                    details,
                    hospital_name: hospitalNameValue || null,
                    hospital_dept: hospitalDeptValue || null,
                    contact_method: contactMethodValue || null,
                    contact_phone: contactPhoneValue || null,
                    visit_date_from: visitDateFromLabel || null,
                    visit_date_to: visitDateToLabel || null,
                    visit_time_from: visitTimeFromValue || null,
                    visit_time_to: visitTimeToValue || null
                };

                if (editingSick) {
                    const pk = getEventPk(editingSick);
                    if (!pk) {
                        showAlert(sickAlert, "error", "تعذر حفظ التعديل لأن معرف السجل غير متوفر.");
                        return;
                    }
                    const res = await rpcUpdateFamilyEventRow(sb, pk, patch);
                    if (!res.ok) {
                        const err = res.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            showAlert(
                                sickAlert,
                                "error",
                                "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                            );
                            return;
                        }
                        if (isCaseTypesTextAndDateMismatchError(err)) {
                            showAlert(
                                sickAlert,
                                "error",
                                "تعذر حفظ التعديل بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                            );
                            return;
                        }
                        const msg = String(err && err.message ? err.message : "");
                        if (msg.toLowerCase().includes("not allowed")) {
                            showAlert(sickAlert, "error", "لا توجد صلاحية لتعديل المناسبات لهذا المندوب.");
                            return;
                        }
                        showAlert(sickAlert, "error", "تعذر حفظ التعديل: " + (msg || "خطأ غير معروف"));
                        return;
                    }
                    touchEventsRefresh();
                    resetSickForm();
                    showAlert(sickAlert, "success", "تم حفظ التعديل.");
                    await loadEventsForBranch(state.branch);
                    return;
                }

                const row = { ...patch, created_at: new Date().toISOString() };
                const res = await rpcInsertFamilyEventRow(sb, row);
                if (!res.ok) {
                    const err = res.error || { message: "unknown error" };
                    if (isRpcMissingError(err)) {
                        showAlert(
                            sickAlert,
                            "error",
                            "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                        );
                        return;
                    }
                    if (isCaseTypesTextAndDateMismatchError(err)) {
                        showAlert(
                            sickAlert,
                            "error",
                            "تعذر الإضافة بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                        );
                        return;
                    }
                    const msg = String(err && err.message ? err.message : "");
                    if (msg.toLowerCase().includes("not allowed")) {
                        if (err && err.detail === "events_access") {
                            const st = String(err.status || "");
                            const rid = String(err.requestId || "");
                            if (st === "pending") {
                                showAlert(sickAlert, "error", rid ? `صلاحية المناسبات قيد المراجعة (رقم الطلب: ${rid}).` : "صلاحية المناسبات قيد المراجعة.");
                                return;
                            }
                            if (st === "rejected") {
                                showAlert(sickAlert, "error", rid ? `تم رفض صلاحية المناسبات (رقم الطلب: ${rid}).` : "تم رفض صلاحية المناسبات.");
                                return;
                            }
                            if (st === "approved") {
                                showAlert(sickAlert, "error", "الصلاحية معتمدة لكن بيانات الدخول لا تطابق بيانات الاعتماد. جرّب تسجيل خروج/دخول وتأكد من البريد والجوال.");
                                return;
                            }
                        }
                        showAlert(sickAlert, "error", "لا توجد صلاحية لإضافة المناسبات لهذا المندوب.");
                        return;
                    }
                    showAlert(sickAlert, "error", "تعذر الإضافة: " + (msg || "خطأ غير معروف"));
                    return;
                }
                maybeOpenEmailDraft(
                    "مناسبة جديدة (" + type + ")",
                    [
                        "مناسبة جديدة",
                        "الفرع: " + state.branch,
                        "النوع: " + type,
                        "الاسم: " + person,
                        dateLabel ? "التاريخ: " + dateLabel : "",
                        notesValue ? "ملاحظات: " + notesValue : ""
                    ]
                        .filter(Boolean)
                        .join("\n")
                );
                touchEventsRefresh();
                resetSickForm();
                showAlert(sickAlert, "success", "تمت الإضافة.");
                await loadEventsForBranch(state.branch);
            });
        }

        if (saveDeathBtn) {
            saveDeathBtn.addEventListener("click", async () => {
                if (!state.branch) {
                    showAlert(deathAlert, "error", "يلزم تسجيل دخول المندوب أولاً.");
                    return;
                }
                const person = normalizePersonName(deathPerson && deathPerson.value ? deathPerson.value : "");
                let dateValue = String(deathDate && deathDate.value ? deathDate.value : "").trim();
                if (!person) {
                    showAlert(deathAlert, "error", "يرجى كتابة اسم المتوفى.");
                    return;
                }
                if (!dateValue) {
                    dateValue = todayGregorianISO();
                    if (deathDate) deathDate.value = dateValue;
                }
                const dateLabel = dateValue ? formatDateISO(dateValue) : "";
                const showDays = clampVisibilityDays(deathVisibilityDays && deathVisibilityDays.value ? deathVisibilityDays.value : 7);
                const payload = {
                    v: 1,
                    kind: "death_notice",
                    prayerPlace: normalizePersonName(prayerPlace && prayerPlace.value ? prayerPlace.value : ""),
                    prayerTime: normalizePersonName(prayerTime && prayerTime.value ? prayerTime.value : ""),
                    burialPlace: normalizePersonName(burialPlace && burialPlace.value ? burialPlace.value : ""),
                    burialTime: normalizePersonName(burialTime && burialTime.value ? burialTime.value : ""),
                    condolencePlace: normalizePersonName(condolencePlace && condolencePlace.value ? condolencePlace.value : ""),
                    condolenceTime: normalizePersonName(condolenceTime && condolenceTime.value ? condolenceTime.value : ""),
                    phones: normalizePhonesForDisplay([
                        condolencePhone1 && condolencePhone1.value ? condolencePhone1.value : "",
                        condolencePhone2 && condolencePhone2.value ? condolencePhone2.value : ""
                    ]),
                    notes: String(deathNotes && deathNotes.value ? deathNotes.value : "").trim(),
                    showDays
                };
                const details = JSON.stringify(payload);

                const sb = getSupabaseClient();
                if (!sb) {
                    showAlert(deathAlert, "error", "تعذر الحفظ لأن الربط غير مُعد.");
                    return;
                }

                const patch = {
                    branch_key: state.branch,
                    type: "death",
                    person,
                    date_label: dateLabel || null,
                    event_date: dateValue || null,
                    details,
                    hospital_name: null,
                    hospital_dept: null,
                    contact_method: null,
                    contact_phone: null,
                    visit_date_from: null,
                    visit_date_to: null,
                    visit_time_from: null,
                    visit_time_to: null
                };

                if (editingDeath) {
                    const pk = getEventPk(editingDeath);
                    if (!pk) {
                        showAlert(deathAlert, "error", "تعذر حفظ التعديل لأن معرف السجل غير متوفر.");
                        return;
                    }
                    const res = await rpcUpdateFamilyEventRow(sb, pk, patch);
                    if (!res.ok) {
                        const err = res.error || { message: "unknown error" };
                        if (isRpcMissingError(err)) {
                            showAlert(
                                deathAlert,
                                "error",
                                "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                            );
                            return;
                        }
                        if (isCaseTypesTextAndDateMismatchError(err)) {
                            showAlert(
                                deathAlert,
                                "error",
                                "تعذر حفظ التعديل بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                            );
                            return;
                        }
                        const msg = String(err && err.message ? err.message : "");
                        if (msg.toLowerCase().includes("not allowed")) {
                            showAlert(deathAlert, "error", "لا توجد صلاحية لتعديل المناسبات لهذا المندوب.");
                            return;
                        }
                        showAlert(deathAlert, "error", "تعذر حفظ التعديل: " + (msg || "خطأ غير معروف"));
                        return;
                    }
                    touchEventsRefresh();
                    resetDeathForm();
                    showAlert(deathAlert, "success", "تم حفظ التعديل.");
                    await loadDeathsForBranch(state.branch);
                    return;
                }

                const row = { ...patch, created_at: new Date().toISOString() };
                const res = await rpcInsertFamilyEventRow(sb, row);
                if (!res.ok) {
                    const err = res.error || { message: "unknown error" };
                    if (isRpcMissingError(err)) {
                        showAlert(
                            deathAlert,
                            "error",
                            "لا يمكن الحفظ الآن لأن دوال المناسبات غير مفعلة في Supabase (family_events_insert_v1 / family_events_update_v1 / family_events_delete_v1)."
                        );
                        return;
                    }
                    if (isCaseTypesTextAndDateMismatchError(err)) {
                        showAlert(
                            deathAlert,
                            "error",
                            "تعذر النشر بسبب مشكلة في نوع التاريخ داخل Supabase. نفّذ SQL تهيئة المناسبات من صفحة الإدارة مرة أخرى ثم أعد المحاولة."
                        );
                        return;
                    }
                    const msg = String(err && err.message ? err.message : "");
                    if (msg.toLowerCase().includes("not allowed")) {
                        if (err && err.detail === "events_access") {
                            const st = String(err.status || "");
                            const rid = String(err.requestId || "");
                            if (st === "pending") {
                                showAlert(deathAlert, "error", rid ? `صلاحية المناسبات قيد المراجعة (رقم الطلب: ${rid}).` : "صلاحية المناسبات قيد المراجعة.");
                                return;
                            }
                            if (st === "rejected") {
                                showAlert(deathAlert, "error", rid ? `تم رفض صلاحية المناسبات (رقم الطلب: ${rid}).` : "تم رفض صلاحية المناسبات.");
                                return;
                            }
                            if (st === "approved") {
                                showAlert(deathAlert, "error", "الصلاحية معتمدة لكن بيانات الدخول لا تطابق بيانات الاعتماد. جرّب تسجيل خروج/دخول وتأكد من البريد والجوال.");
                                return;
                            }
                        }
                        showAlert(deathAlert, "error", "لا توجد صلاحية لإضافة المناسبات لهذا المندوب.");
                        return;
                    }
                    showAlert(deathAlert, "error", "تعذر النشر: " + (msg || "خطأ غير معروف"));
                    return;
                }
                maybeOpenEmailDraft(
                    "خبر وفاة جديد",
                    [
                        "خبر وفاة جديد",
                        "الفرع: " + state.branch,
                        "الاسم: " + person,
                        dateLabel ? "التاريخ: " + dateLabel : "",
                        payload.prayerPlace ? "مكان الصلاة: " + payload.prayerPlace : "",
                        payload.prayerTime ? "وقت الصلاة: " + payload.prayerTime : "",
                        payload.burialPlace ? "مكان الدفن: " + payload.burialPlace : "",
                        payload.burialTime ? "وقت الدفن: " + payload.burialTime : "",
                        payload.condolencePlace ? "مكان العزاء: " + payload.condolencePlace : "",
                        payload.condolenceTime ? "وقت العزاء: " + payload.condolenceTime : "",
                        payload.phones ? "الجوال: " + payload.phones : "",
                        payload.notes ? "ملاحظات: " + payload.notes : ""
                    ]
                        .filter(Boolean)
                        .join("\n")
                );
                touchEventsRefresh();
                resetDeathForm();
                showAlert(deathAlert, "success", "تم نشر خبر الوفاة.");
                await loadDeathsForBranch(state.branch);
            });
        }

        updateSickPlaceVisibility();
        updateSickContactModeVisibility();
        renderHappyEvents();
        renderSickEvents();
        renderDeaths();
    </script>
</body>
</html>
